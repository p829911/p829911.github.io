{"meta":{"title":"data science study blog","subtitle":"DS Study Blog","description":null,"author":"Seungwoo Hyun","url":"https://p829911.github.io"},"pages":[],"posts":[{"title":"다중 선형 회귀","slug":"regression","date":"2018-12-06T12:33:47.000Z","updated":"2018-12-06T12:42:57.749Z","comments":true,"path":"2018/12/06/regression/","link":"","permalink":"https://p829911.github.io/2018/12/06/regression/","excerpt":"","text":"다중 선형 회귀 설명변수들 $X_1, X_2, \\cdots, X_p$ 중 적어도 하나는 반응변수를 예측하는데 유용한가? $Y$를 설명하는 데 모든 설명변수들이 도움이 되는가? 또는 설명변수들의 일부만이 유용한가? 모델은 데이터에 얼마나 잘 맞는가? 주어진 설명변수 값들에 대해 어떤 반응변수 값을 예측해야 하고 그 예측은 얼마나 정확한가? 1. 반응변수와 설명변수 사이에 상관관계가 있는가? 단순선형회귀에서 반응변수와 설명변수 사이에 상관관계가 있는지는 단순히 $\\beta_1 = 0$인지 검사하면 결정할 수 있다. $p$개 설명변수가 있는 다중회귀에서는 모든 회귀계수들이 영인지, 즉 $\\beta_1 = \\beta_2 = \\cdots = \\beta_p =0$인지를 검사해야 한다. 단순선형회귀에서와 같이 이 질문에 답하기 위해 가설검정을 사용한다. 귀무가설 H_0 : \\beta_1 = \\beta_2 = \\cdots = \\beta_p = 0대립가설 H_a: \\text{적어도 하나의 }\\beta_j\\text{는 영이 아니다.}이러한 가설 검정은 $F$-통계량을 계산함으로써 이루어진다. F = \\dfrac{(\\text{TSS} - \\text{RSS})/p}{\\text{RSS}/(n-p-1)}단순선형회귀에서와 같이 $\\text{TSS} = \\sum(y_i-\\bar{y})^2$ 이고 $\\text{RSS} = \\sum(y_i - \\hat{y_i})^2$이다. 만약 선형 모델의 가정이 같다면 다음이 성립함을 보여줄 것이다. E[\\,\\text{RSS}\\, / \\,(n-p-1)\\,] = \\sigma^2또한 귀무가설 $H_0$이 참이면 다음이 성립함을 보여줄 수도 있다. E[\\,(\\text{TSS} - \\text{RSS})\\,/\\,p\\,] = \\sigma^2그러므로, 반응변수와 설명변수들 사이에 상관관계가 없는 경우(RSS가 커질때 TSS와 거의 가까움) $F$- 통계량이 1에 매우 가까운 값이라고 기대할 수 있을 것이다. 반면에 만약 대립가설 $H_a$가 참이면 $E[\\,(\\text{TSS}-\\text{RSS})\\,/\\, p\\,] &gt; \\sigma^2$이고 그래서 $F$의 기대값은 1보다 크다. $H_0$을 기각하고 상관관계가 있다고 결론을 내릴 수 있으면 $F$-통계량이 얼마나 커야될까? $n\\text{과} p$값에 따라 다르다. $n$이 큰 경우에는 $F$-통계량이 1보다 약간만 크면 $H_0$에 반하는 증거가 된다. $n$이 작은 경우 $H_0$를 기각하려면 더 큰 $F$-통계량이 필요하다. 2. 중요 변수의 결정 모든 설명변수가 반응변수와 상관성이 있을 수도 있다. 하지만 대부분의 경우 설명변수들의 일부(서브셋)만이 반응변수와 상관관계가 있다. 상관성이 있는 설명변수만으로 모델 적합을 수행하기 위해 어느 설명변수가 반응변수와 상관성이 있는지 결정하는 것을 변수선택이라고 한다. 모델의 질 평가 맬로우즈(Mallows) $C_p$ AIC (Akaike information criterion) BIC (Bayesian information criterion) 수정된 $R^2$ $p$개 변수들의 일부를 포함하는 총 모델의 경우의 수는 $2^p$개에 이른다. 심지어 $p$가 크지 않더라도 모든 가능한 설명변수들의 부분집합을 다 시험해 보는 것은 현실적으로 어렵다. 예를 들어 $p = 2$인 경우 $2^2 = 4$모델을 고려하면 된다. 그러나 $p=30$이면 고려해야 하는 모델 수는 $2^{30} = 1,073,741,824$개로 늘어나 현실적으로 불가능에 가깝다. 그러므로 $p$가 아주 작은 경우가 아니면 $2^p$개 모델 모두를 고려할 수는 없고, 대신에 더 작은 수의 고려할 모델 집합을 선택하는 자동화되고 효과적인 기법이 필요하다. 이 목적을 위한 3가지 고전적인 기법은 아래와 같다. 전진선택: 이 방법은 절편만 포함하고 설명변수는 없는 영모델(null model)을 가지고 시작한다. $p$개의 단순 선형 회귀를 적합하여 가장 낮은 $RSS$가 발생되는 변수를 영모델에 추가한다. 그런 다음 새로운 새로운 2-변수 모델에 대해 가장 낮은 $RSS$가 생기는 변수를 모델에 추가한다. 이런 방식으로 어떤 정지규칙(stopping rule)을 만족할 때까지 계속된다. 후진선택(Backward selection): 이 방법은 모델의 모든 변수를 가지고 시작하여 가장 큰 $p$-값을 가지는 변수, 즉 통계적으로 중요도가 가장 낮은 변수를 제외한다. 그 다음에 새로운 (p-1)-변수의 모델을 적합하고 $p$-값이 가장 큰 변수를 제외한다. 이 과정을 정지 규칙이 만족될 때까지 계속한다. 예를 들어 모든 남아있는 변수들의 $p$-값이 어떤 임계치보다 작으면 이 과정을 중지한다. 혼합선택(Mixed selection): 이것은 전진선택과 후진선택을 결합한 것이다. 전진선택처럼 변수가 없는 모델로 시작하여 최상의 적합을 제공하는 변수를 하나씩 추가한다. 새로운 설명변수들이 모델에 추가됨에 따라 변수들에 대한 $p$-값이 커질 수 있다. 그러므로 모델의 변수들 중 어느 하나에 대한 $p$-값이 어떤 임계치보다 커지면 그 변수를 모델에서 제외한다. 이러한 전진선택 및 후진선택 단계를 계속하여 모델에 포함되는 모든 변수들은 충분히 작은 $p$-값을 가지고 모델에서 제외된 변수들은 만약 모델에 추가될 경우 $p$-값이 크게 될 때 중지한다. 후진 선택법은 만약 p &gt; n 이면 사용할 수 없지만 전진선택법은 항상 사용할 수 있다. 전진선택법은 그리디(greedy)방식이다. 그래서 초기에 포함된 변수들이 나중에는 유효하지 않을 수 있다. 이 문제는 혼합선택법으로 선택할 수 있다. 3. 모델 적합 모델 적합의 수치적 측도로 가장 흔히 사용되는 두가지는 $RSE$와 $R^2$(설명되는 분산의 비율)이다. 이 값들은 단순선형회귀에서와 같은 방식으로 계산되고 해석된다. 단순회귀에서 $R^2$은 반응변수와 설명변수의 상관계수의 곱이다. 다중 선형회귀에서 이것은 반응변수와 적합된 선형모델 사이의 상관계수의 제곱인 $Cor(Y,\\hat{Y})^2$과 동일하다. 사실 적합된 선형모델은 모든 가능한 선형모델 중에서 이 상관계수가 최대로 되는 것이다. 1에 가까운 $R^2$값은 모델이 반응변수 내 분산의 많은 부분을 설명한다는 것을 나타낸다. 모델에 더 많은 변수가 추가되면 비록 추가된 변수와 반응변수의 상관관계가 아주 약하더라도 $R^2$은 항상 증가할 것이다. 이것은 최소제곱 방정식에 변수를 추가하면 훈련 데이터(반드시 검정 데이터일 필요는 없다.)를 더 정확하게 적합할 수 있다는 사실 때문이다. 특정 독립 변수를 추가했을 때 $R^2$이 약간만 증가한다는 사실은 그 독립 변수가 모델에서 제외될 수 있다는 추가적인 증거가 된다. 모델에 그 독렵변수를 포함하는 것은 독립적인 검정표본에 대한 과적합으로 인해 좋지 않은 결과를 초래할 가능성이 높을 것이다. 4. 예측 다중선형모델 적합을 수행하였으면 $\\hat{y} = \\hat{\\beta_0} + \\hat{\\beta_1}x_1 + \\hat{\\beta_2}x_2 + \\cdots + \\hat{\\beta_p}x_p$을 적용하여 설명변수 $X_1, X_2, \\cdots, X_p$의 값에 기초하여 반응 변수 $Y$를 예측하는 것은 어렵지 않다. 하지만, 이러한 예측에는 세 가지 명확하지 않은 것이 연관되어 있다. 계수추정 $\\hat{\\beta_0}, \\hat{\\beta_1}, \\cdots, \\hat{\\beta_p}$는 $\\beta_0,\\beta_1,\\cdots, \\beta_p$에 대한 추정값이다. 즉 아래 최소제곱평면은 \\hat{Y} = \\hat{\\beta_0} + \\hat{\\beta_1}X_1 + \\cdots + \\hat{\\beta_p}X_p다음의 실제 모회귀평면에 대한 추정값이다. f(X) = \\beta_0 + \\beta_1X_1 + \\cdots + \\beta_pX_p계수추정의 부정확도는 2장의 축소가능 오차(reducible error)와 관련된다. 신뢰구간을 계산하여 $\\hat{Y}$가 $f(x)$에 얼마나 가까운지 결정할 수 있다. 물론, 실제로 $f(x)$에 대해 선형 모델을 가정하는 것은 거의 항상 현실에 대한 근사이다. 따라서 모델 편향(model bias)이라고 하는 잠재적으로 축소가능한 오차의 또 다른 출처가 있다. 그러므로 선형모델을 사용할 때 실제 표면에 대한 최상의 선형 근사를 추정하는 것이다. 하지만, 여기서는 이러한 차이를 무시하고 마치 선형 모델이 올바른 것으로 간주한다. 심지어 $f(x)$를 알아도 - $\\beta_0, \\beta_1, \\cdots, \\beta_p$에 대한 실제 값을 알아도 - 모델의 랜덤오차 때문에 반응변수 값을 완벽하게 예측할 수는 없다. 2장에서 이 오차를 축소불가능 오차(irreducible error)라고 하였다. 선형 모델의 확장표준선형회귀모델 $Y = \\beta_0 + \\beta_1X1 + \\beta_2X2 + \\cdots + \\beta_pX_p + \\epsilon$ 는 해석이 가능한 결과를 제공하며 많은 현실적인 문제에 대해서도 잘 동작한다. 하지만 이것은 실제로는 성립되지 않는 몇 가지 아주 제한적인 가정을 사용한다. 가장 중요한 가정 중 두 가지는 설명변수와 반응변수 사이의 관계는 가산적(additive)이고 선형적이라는 것이다. 가산성 가정: 설명변수 $X_j$의 변화가 반응변수 $Y$에 미치는 영향은 다른 설명변수 값에 독립적이다. 선형성 가정: $X_j$의 한 유닛 변화로 인한 $Y$의 변화는 $X_j$의 값에 관계없이 상수이다. 가산성 가정의 제거 Advertising 자료 분석에서 TV와 radio 둘 다 sales와 상관관계가 있다고 결론지었다. 이러한 결론의 근거가 되는 선형모델들은 한 광고매체의 지출 증가가 sales에 미치는 영향은 다른 매체에 대한 지출과 무관하다고(독립적이라고) 가정한다. 하지만, 이런 단순한 모델은 맞지 않을 수 있다. 라디오 광고 지출이 실제로 TV 광고의 효과를 증가시켜 TV에 대한 기울기 항이 라디오 지출이 늘어남에 따라 증가해야 한다고 해보자. 이러한 경우, 주어진 10만 달러의 고정 광고예산을 라디오와 TV에 절반씩 지출하는 것이 전체 예산을 TV 또는 라디오 어느 한쪽에 모두 사용하는 것보다 판매량 증가가 더 클 수 있다. 이것을 마케팅에서는 시너지 효과 라 하고 통계학에서는 상호작용 효과 라 한다. 두 개의 변수를 가지는 표준 선형회귀모델을 고려해보자 Y = \\beta_0+\\beta_1X_1+\\beta_2X_2+\\epsilon이 모델에 따르면 $X_1$이 한 유닛 증가하면 $Y$는 평균 $\\beta_1$유닛만큼 증가할 것이다. $X_2$의 존재는 이 사실을 변경하지 않는다. 즉, $X_2$의 값에 관계없이 $X_1$이 한 유닛 증가하면 $Y$는 $\\beta_1$ 유닛 증가할 것이다. 상호작용 효과를 포함하도록 이 모델을 확장하는 한 가지 방법은 상호작용 항이라 불리는 세 번째 설명변수를 포함하는 것이다. 상호작용 항은 $X_1$과 $X_2$의 곱으로 구성된다. 그러면 결과 모델은 다음과 같이 표현 된다. Y = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + \\beta_3X_1X_2 + \\epsilon위의 식은 아래와 같이 다시 쓸 수 있다. \\begin{eqnarray} Y &=& \\beta_0 + (\\beta_1 + \\beta_3X_2)X_1 + \\beta_2X_2 + \\epsilon\\\\ &=& \\beta_0 + \\tilde{\\beta_1}X_1 + \\beta_2X_2 + \\epsilon \\end{eqnarray}여기서 $\\tilde{\\beta_1} = \\beta_1 + \\beta_3X_2$이다. $\\tilde{\\beta_1}$은 $X_2$에 따라 변하므로 $Y$에 대한 $X_1$의 효과는 더이상 상수가 아니다. $X_2$를 조정하면 $Y$에 대한 $X_1$의 효과가 변할 것이다. 이것은 실제 상관관계는 가산적이지 않다는 것이 명백하다. 가끔씩 상호작용 항은 매우 작은 $p$-값을 가지지만 관련된 주효과는 그렇지 않은 경우도 있다. 계층적 원리 에 의하면, 만약 모델에 상호작용을 포함하면 주효과는 그 계수와 연관된 $p$-값이 유의하지 않더라도 모델에 포함해야 한다. 다시 말해, 만약 $X_1$과 $X_2$사이의 상호작용이 중요한 것 같으면 $X_1$과 $X_2$의 계수 추정치가 큰 $p$-값을 가져도 모델에 $X_1$과 $X_2$를 포함해야 한다. 이유는 만약 $X_1 \\times X_2 $가 반응변수와 상관관계가 있으면 $X_1$또는 $X_2$의 계수가 영인지는 관심이 없다. 또한 $X_1 \\times X_2$는 보통 $X_1$ 및 $X_2$와 상관되어 있어 이들을 제외하는 것은 상호작용의 의미를 바꾸는 경향이 있다. 상호작용의 개념은 질적 변수 또는 양적 변수와 질적 변수의 조합에도 적용된다. 사실, 질적 변수와 양적 변수 사이의 상호작용을 해석하기는 특히 쉽다. 상호작용 항이 없을 경우 모델은 다음 형태를 가진다. \\begin{eqnarray} \\text{balance}_i &\\approx& \\beta_0 + \\beta_1 \\times \\text{income}_i + \\begin{cases}\\beta_2 & i\\text{번째 사람이 학생인 경우} \\\\ 0 & i\\text{번째 사람이 학생이 아닌 경우} \\end{cases} \\\\\\\\ &=& \\beta_1 \\times \\text{income}_i + \\begin{cases}\\beta_0 + \\beta_2 & i\\text{번째 사람이 학생인 경우} \\\\ \\beta_0 & i\\text{번째 사람이 학생이 아닌 경우}\\end{cases} \\end{eqnarray}이것은 두 개의 평행한 직선을 데이터에 적합하는 것이다. 학생과 학생이 아닌 사람에 대한 두 직선은 다른 절편 $\\beta_0 + \\beta_2$와 $\\beta_0$을 가지지만 동일한 기울기 $\\beta_1$을 가진다. 두 직선이 평행하다는 사실이 의미하는 것은 income의 한 유닛 증가가 balance에 미치는 평균 효과는 그 사람이 학생인지 아닌지에 의존적이지 않다는 것을 의미한다. 이것은 모델이 잠재적으로 심각한 한계가 있음을 나타낸다. 왜냐하면 소득의 변화는 학생과 학생이 아닌 사람의 신용카드 대금에 아주 다른 효과를 줄 수 있기 때문이다. 이 한계는 income을 student에 대한 가변수와 곱하여 얻은 상호작용 변수를 추가함으로써 해결할 수 있다. 그러면 모델은다음과 같이 표현된다. \\begin{eqnarray} \\text{balance}_i &\\approx& \\beta_0 + \\beta_1 \\times \\text{income}_i + \\begin{cases}\\beta_2 + \\beta_3 \\times \\text{income}_i & \\text{학생인 경우}\\\\ 0 & \\text{학생이 아닌 경우}\\end{cases}\\\\ \\\\ &=& \\begin{cases}(\\beta_0 + \\beta_2) + (\\beta_1 + \\beta_3) \\times \\text{income}_i & 학생인 경우 \\\\ \\beta_0 + \\beta_1 \\times \\text{income}_i & \\text{학생이 아닌 경우}\\end{cases} \\end{eqnarray}이 경우에도 학생과 학생이 아닌 사람에 대한 회귀 직선이 다르다. 그러나 이번에는 두 직선의 절편 뿐만 아니라 기울기도 다르다. 학생인 경우, 회귀직선의 절편은 $\\beta_0 + \\beta_2$, 기울기는 $\\beta_1 + \\beta_3$이다. 학생이 아닌 경우에는 절편은 $\\beta_0$, 기울기는 $\\beta_1$이다. 이것은 소득 변화가 신용카드 대금에 미치는 영향이 학생인지의 여부에 따라 다를 수 있게 한다. 학생에 대한 기울의 기울기가 학생이 아닌 경우에 대한 것보다 작은데, 이것은 소득 증가에 따른 카드 대금의 증가가 학생인 경우 학생이 아닌 사람보다 낮다는 것을 시사한다. 비선형 상관관계","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Regression","slug":"Math/Regression","permalink":"https://p829911.github.io/categories/Math/Regression/"}],"tags":[{"name":"regression","slug":"regression","permalink":"https://p829911.github.io/tags/regression/"},{"name":"math","slug":"math","permalink":"https://p829911.github.io/tags/math/"}]},{"title":"git 설치 & 사용법","slug":"git-install-and-how-to-use","date":"2018-12-03T12:58:52.000Z","updated":"2018-12-03T14:34:41.550Z","comments":true,"path":"2018/12/03/git-install-and-how-to-use/","link":"","permalink":"https://p829911.github.io/2018/12/03/git-install-and-how-to-use/","excerpt":"","text":"git은 터미널에서 다음과 같은 명렁어로 설치 할 수 있다.1sudo apt-get install git 설치가 완료 되었으면 1git --version git config 설정 1234git config --global user.name \"username\"git config --global user.email \"github email address\"git config --global core.editor \"vim\"git config --list local에 있는 폴더와 git 저장소 연동시키기 폴더 생성 후 git init 해주기 123git initgit add.git commit -m \"contents\" git repository 생성 해 준 후 12git remote add origin https://github.com/username/repo.gitgit push origin master 위의 코드에서 origin이라는 부분은 사용자가 지정할 수 있지만, 보통 origin이라고 써줌 git 에서 저장소를 clone 할 때는 자동적으로 origin이라고 지정 된다. git 저장소 local 폴더로 복제하기1git clone https://github.com/username/repo.git 개인적으로는 git remote 보다 git clone해서 사용하는 것이 더 편하다. branch소프트웨어를 개발할 때 개발자들은 동일한 소스코드를 함께 공유한다. 동일한 소스코드 위에서 서로 다른 작업을 할 때는 각각 서로 다른 버전의 코드가 만들어 질 수 밖에 없다.이럴 때, 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능이 바로 ‘브랜치(Branch)’이다.이렇게 분리된 작업 영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다. 브랜치란 독립적으로 어떤 작업을 진행하기 위한 개념이다. 필요에 의해 만들어지는 각각의 브랜치는 다른 브랜치의 영향을 받지 않기 때문에, 여러 작업을 동시에 진행할 수 있다. 또한 이렇게 만들어진 브랜치는 다른 브랜치와 병합(Merge)함으로써, 작업한 내용을 다시 새로운 하나의 브랜치로 모을 수 있다. 저장소를 처음 만들면, Git은 바로 ‘master’라는 이름의 브랜치를 만들어 준다. 이 새로운 저장소에 새로운 파일을 추가한다거나 추가한 파일의 내용을 변경하여 그 내용을 저장(커밋, commit)하는 것은 모두 ‘master’라는 이름의 브랜치를 통해 처리할 수 있다. 12345678git branch &lt;branchname&gt; # 브랜치 생성git branch # 브랜치 확인git branch -r # remote 브랜치 확인git branch -a # 모든 사용가능한 브랜치 확인git chechout &lt;branchname&gt; # 브랜치 지정git checkout -b &lt;branchname&gt; # 브랜치 생성, 체크아웃git merge &lt;commit&gt; # 브랜치 병합git branch -d &lt;branchname&gt; # 브랜치 삭제 참고 https://backlog.com/git-tutorial/kr/stepup/stepup1_1.html https://github.com/ulgoon/dss-linux-git","categories":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/tags/Git/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"ubuntu permission","slug":"ubuntu-permission","date":"2018-11-27T08:44:04.000Z","updated":"2018-11-28T09:35:45.453Z","comments":true,"path":"2018/11/27/ubuntu-permission/","link":"","permalink":"https://p829911.github.io/2018/11/27/ubuntu-permission/","excerpt":"","text":"파일 정보 보기 ls -al: 현재 위치에 있는 파일들을 자세히 보여주는 명령 파일 Type 퍼미션정보 링크수 소유자 소유그룹 용량 생성날짜 파일이름 d rwxr-xr-x 28 p829911 p829911 4096 11월 27 20:30 .ipython 파일 Type: d (디렉토리), ㅣ (링크파일), - (일반파일) 퍼미션정보: 해당 파일에 어떠한 퍼미션이 부여되어 있는지 링크수: 해당 파일이 링크된 수, 윈도우의 바로가기와 같다. in [대상파일][링크파일]명령으로 만든다. 소유자: 해당 파일의 소유자 이름 소유그룹: 해당 파일을 소유한 그룹이름 용량: 파일의 용량 생성날짜: 파일이 생성된 날짜 파일이름: 파일의 이름 퍼미션 정보 앞에서 두번째부터 아홉번째까지 퍼미션 정보이다. rwxr-xr-x 퍼미션 종류 r : 파일의 읽기 권한 w : 파일의 쓰기 권한 x : 파일의 실행 권한 퍼미션의 사용자지정 소유자: 소유자에 대한 퍼미션 지정 rwx 그룹: 소유그룹에 대한 퍼미션 지정 r-x 공개: 모든 사용자들에 대한 퍼미션 지정 r-x -: 그 퍼미션은 없다 소유자는 읽기, 쓰기, 실행을 허용하고 파일의 소유그룹에 속하고 있는 사용자들은 읽기 실행만 허용하고 이외에 나머지 모든 사용자들도 읽기, 실행만 허용한다. 퍼미션 변경하기chmod [변경될 퍼미션값][변경할 파일] 각 퍼미션 기호를 숫자로 변환한다. ( r = 4, w = 2, x = 1)ex) r - x = 4 0 1 변환한 숫자를 합산한다.ex) 4 0 1 = 5 rwxr-xr-x = 755 chmod 775 [변경할 파일] : 변경할 파일이 755에 해당되는 퍼미션으로 변경된다. 디렉토리의 경우 -R 옵션을 사용하면 하위 디렉토리의 모든 디렉토리 및 파일의 퍼미션이 변경된다.ex) chmod -R 777 [변경할 디렉토리] 소유자 변경하기chown [변경할 소유자][변경할 파일] 이 명령으로 소유자뿐만 아니라 소유그룹도 변경할 수 있다. [변경할 소유자]에 .그룹이름 형식으로 입력하면 된다. ex) p829911.text 파일의 소유자를 p829911 소유그룹을 p829911로 동시에 변경할 경우chown p829911.p829911 p829911.text","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"ubuntu apt 명령어","slug":"ubuntu-apt-명령어","date":"2018-11-27T07:50:51.000Z","updated":"2018-11-27T08:05:17.038Z","comments":true,"path":"2018/11/27/ubuntu-apt-명령어/","link":"","permalink":"https://p829911.github.io/2018/11/27/ubuntu-apt-명령어/","excerpt":"","text":"우분투에서 패키지를 관리하는 명령어가 몇 가지 있다. 그 중 apt-get과 apt-cache를 결합한 apt에 관한 명령어를 알아보겠다. 패키지 목록 갱신 1apt update 모든 패키지를 최신 버전으로 업그레이드 12apt install upgradeapt full-upgrade # 의존성 고려한 패키지 업그레이드 패키지 설치 1apt install package_name 패키지 삭제 1apt remove package_name 패키지 삭제(설정 파일 포함) 1apt purge package_name 불필요한 패키지 제거 1apt autoremove 패키지 검색 1apt search package_name 패키지 상세 정보 출력 1apt show package_name apt 명령어 사용법 &amp; 옵션 1apt -h 패키지 리스트 출력 1apt list 권한 문제가 발생할 경우 sudo 명령을 붙여 root로 실행할 수 있다.","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"교차 검증","slug":"교차-검증","date":"2018-11-27T06:32:01.000Z","updated":"2018-11-28T10:03:23.780Z","comments":true,"path":"2018/11/27/교차-검증/","link":"","permalink":"https://p829911.github.io/2018/11/27/교차-검증/","excerpt":"","text":"이 포스트는 fastcampus에서 강의를 하고 계시는 김도형 박사님의 강의록을 따라 쓰며 연습한 포스트입니다. 데이터 사이언스 스쿨 표본 내 성능과 표본 외 성능회귀분석 모형을 만들기 위해서는 모수 추정 즉 학습을 위한 데이터 집합이 필요하다. 보통 회귀분석 성능을 이야기할 때는 이 학습 데이터 집합의 종속 변수값을 얼마나 잘 예측하였는지를 결정 계수(codefficient of determination) 등을 이용하여 따진다. 이러한 성능을 표본 내 성능 검증(in-sample testing)이라고 한다. 그런데 회귀분석 모형을 만드는 목적 중 하나는 종속 변수의 값을 아직 알지 못하고 따라서 학습에 사용하지 않은 표본에 대해 종속 변수의 값을 알아내고자 하는 것 즉 예측(prediction)이다. 이렇게 학습에 쓰이지 않는 표본 데이터 집합의 종속 변수 값을 얼마나 잘 예측하는가를 검사하는 것을 표본 외 성능 검증(out-of-sample testing) 혹은 교차 검증(cross validation)이라고 한다. 과최적화일반적으로 표본 내 성능과 표본 외 성능은 비슷한 수준을 보이지만 경우에 따라서는 표본 내 성능은 좋으면서 표본 외 성능이 상대적으로 많이 떨어지는 수도 있다. 이러한 경우를 과최적화(overfitting)라고 한다. 과최적화가 발생하면 학습에 쓰였던 표본 데이터에 대해서는 종속변수의 값을 잘 추정하지만 새로운 데이터를 주었을 때 전혀 예측하지 못하기 때문에 예측 목적으로는 쓸모없는 모형이 된다. 검증용 데이터 집합교차 검증을 하려면 두 종류의 데이터 집합이 필요하다. 모형 추정 즉 학습을 위한 데이터 집합 (training data set) 성능 검증을 위한 데이터 집합 (test data set) 두 데이터 집합 모두 종속 변수값이 있어야 한다. 따라서 보통은 가지고 있는 데이터 집합을 학습용과 검증용으로 나누어 학습용 데이터만을 사용하여 회귀분석 모형을 만들고 검증용 데이터로 성능을 계산하는 학습/검증 데이터 분리(train-test split) 방법을 사용한다. statsmodels 패키지에서의 교차 검증사실 소수의 입력 변수와 소규모 데이터를 사용하는 전통적인 회귀분석에서는 다항 회귀 등의 방법으로 모형 차수를 증가시키지 않는 한 과최적화가 잘 발생하지 않는다. 따라서 statsmodels 패키지에는 교차 검증을 위한 기능이 별도로 준비되어 있지 않고 사용자가 직접 코드를 작성해야 한다. scikit-learn의 교차 검증 기능독립 변수의 개수가 많은 빅데이터에서는 과최적화가 쉽게 발생한다. 따라서 scikit-learn 의 model_selection 서브 패키지는 교차 검증을 위한 다양한 명령을 제공한다. 단순 데이터 분리train_test_split 명령은 데이터를 학습용 데이터와 검증용 데이터로 분리한다. 1train_test_split(data, data2, test_size, train_size, random_state) data: 독립 변수 데이터 배열 또는 pandas 데이터 프레임 data2: 종속 변수 데이터. data인수에 종속 변수 데이터가 같이 있으면 생략할 수 있다. test_size: 검증용 데이터 개수. 1보다 작은 실수이면 비율을 나타낸다. train_size: 학습용 데이터의 개수. 1보다 작은 실수이면 비율을 나타낸다. test_size와 train_size중 하나만 있어도 된다. random_state: 난수 시드 1234from sklearn.model_selection import train_test_splitdf_train, df_test = train_test_split(df, test_size=0.3, random_state=0)df_train.shape, df_test.shape 12dfx_train, dfx_test, dfy_train, dfy_test = train_test_split(dfx, dfy, test_size=0.3, random_state=0)dfx_train.shape, dfy_train.shape, dfx_test.shape, dfy_test.shape K- 폴드 교차 검증데이터의 수가 적은 경우에는 이 데이터 중의 일부인 검증 데이터의 수도 적기 때문에 검증 성능의 신뢰도가 떨어진다. 그렇다고 검증 데이터의 수를 증가시키면 학습용 데이터의 수가 적어지므로 정상적인 학습이 되지 않는다. 이러한 딜레마를 해결하기 위한 검증 방법이 K-폴드(K-fold) 교차 검증 방법이다. K-폴드 교차 검증에서는 전체 데이터를 K개의 부분집합($\\{1, 2, \\cdots , K\\}$)로 나눈 뒤 다음과 같이 학습과 검증을 반복한다. 데이터 $\\{1, 2, \\cdots, K - 1\\}$를 학습용 데이터로 사용하여 회귀분석 모형을 만들고 데이터 $\\{K\\}$ 로 교차 검증을 한다. 데이터 $\\{1, 2, \\cdots, K - 2, K\\}$를 학습용 데이터로 사용하여 회귀분석 모형을 만들고 데이터 $\\{K-1\\}$로 교차 검증을 한다. $\\vdots$ 데이터 $\\{2, \\cdots, K\\}$를 학습용 데이터로 사용하여 회귀분석 모형을 만들고 데이터 $\\{1\\}$로 교차 검증을 한다. 이렇게 하면 총 K개의 모형과 K개의 교차 검증 성능이 나온다. 이 K개의 교차 검증 성능을 평균하여 최종 교차 검증 성능을 계산한다. scikit-learn 패키지의 model_selection 서브 패키지는 KFold 클래스를 비롯한 다양한 교차 검증 생성기를 제공한다. 이 생성기의 split 메서드는 학습용과 검증용의 데이터 인덱스를 출력하는 파이썬 반복자(iterator)를 반환한다. 123456789101112131415161718from sklearn.model_selection import KFoldscores = np.zeros(5)cv = KFold(5, shuffle=True, random_state=0)for i, (idx_train, idx_test) in enumerate(cv.split(df)): df_train = df.iloc[idx_train] df_test = df.iloc[idx_test] model = sm.OLS.from_formula(\"MEDV ~ \" + \"+\".join(boston.feature_names), data=df_train) result = model.fit() pred = result.predict(df_test) rss = ((df_test.MEDV - pred) ** 2).sum() tss = ((df_test.MEDV - df_test.MEDV.mean()) ** 2).sum() rsquared = 1 - rss/tss scores[i] = rsquared print(\"train R2 = &#123;:.8f&#125;, test R2 = &#123;:.8f&#125;\".format(result.rsquared, rsquared))","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Regression","slug":"Math/Regression","permalink":"https://p829911.github.io/categories/Math/Regression/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"}]},{"title":"hexo mathjax","slug":"hexo-mathjax","date":"2018-11-26T14:36:53.000Z","updated":"2018-11-26T14:53:50.702Z","comments":true,"path":"2018/11/26/hexo-mathjax/","link":"","permalink":"https://p829911.github.io/2018/11/26/hexo-mathjax/","excerpt":"","text":"rendering engine changeHexo의 기본 renderer인 hexo-renderer-marked는 mathjax 문법을 지원하지 않는다. 따라서 mathjax를 지원하는 rendering engine으로 교체해준다. 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save &lt;blog dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js를 열어 return값을 text로 수정한다. 12345function formatText(text) &#123; // Fit kramed's rule: $$ + \\1 + $$ // return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$'); return text;&#125; install mathjaxmathjax plugin 설치 1npm install hexo-renderer-mathjax --save &lt;blog dir&gt;/node_modules/hexo-renderer-kramed/node_modules/hexo-renderer-mathjax/mathjax.html 을 열고 URL을 수정해준다. 12&lt;!-- &lt;script src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"&gt;&lt;/script&gt; --&gt;&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'&gt;&lt;/script&gt; LaTex와 markdown 문법 충돌 해결하기&lt;blog dir&gt;/node_modules/kramed/lib/rules/inline.js를 열고 다음과 같이 수정한다. 12escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, Mathjax 사용하기사용하고 있는 theme의 _config.yml파일을 열고 다음과 같이 수정한다. 12mathjax: enable: true markdown post 작성post 작성시 header 부분에 mathjax: true를 넣어주면 블로그에서 수식이 보이게 된다.","categories":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/tags/Git/"},{"name":"Blog","slug":"Blog","permalink":"https://p829911.github.io/tags/Blog/"},{"name":"Mathjax","slug":"Mathjax","permalink":"https://p829911.github.io/tags/Mathjax/"}]},{"title":"분산 분석","slug":"분산-분석","date":"2018-11-26T14:21:57.000Z","updated":"2018-12-04T08:38:03.505Z","comments":true,"path":"2018/11/26/분산-분석/","link":"","permalink":"https://p829911.github.io/2018/11/26/분산-분석/","excerpt":"","text":"이 포스트는 fastcampus에서 강의를 하고 계시는 김도형 박사님의 강의록을 따라 쓰며 연습한 포스트입니다. 데이터 사이언스 스쿨 선형회귀분석의 결과가 얼마나 좋은지는 단순히 잔차제곱합(RSS: Residual sum of square)으로 평가할 수 없다. 변수의 단위 즉, 스케일이 달라지면 회귀분석과 상관없이 잔차제곱합도 달라지기 때문이다. 분산 분석(ANOVA: Analysis of Variance)은 종속변수의 분산과 독립변수의 분산간의 관계를 사용하여 선형회귀분석의 성능을 평가하고자 하는 방법이다. 분산 분석은 서로 다른 두 개의 선형회귀분석의 성능 비교에 응용할 수 있으며 독립변수가 카테고리 변수인 경우 각 카테고리 값에 따른 영향을 정량적으로 분석하는데도 사용된다. $\\hat{y}$를 종속변수 $y$의 샘플 평균이라고 하자. \\hat{y} = \\frac{1}{N} \\sum_{i=1}^N y_iTSS (total sum of squares) \\text{TSS} = \\sum_{i=1}^N (y_i-\\bar{y})^2 = (y-\\bar{y})^T(y-\\bar{y})종속변수값의 움직임의 범위를 나타낸다. ESS(explained sum of squares) \\text{ESS} = \\sum_{i=1}^N (\\hat{y_i}-\\bar{\\hat{y}})^2 = (\\hat{y}-\\bar{\\hat{y}})^T(\\hat{y}-\\bar{\\hat{y}})회귀 분석에 의해 예측한 값 $\\hat{y}$의 분산을 나타낸다. 모형에서 나온 예측값의 움직임의 범위를 뜻한다. RSS (residual sum of squares) \\text{RSS} = \\sum_{i=1}^N(y_i-\\hat{y_i})^2 = e^Te잔차 $e$의 분산을 나타낸다. 잔차의 움직임의 범위, 즉 오차의 크기를 뜻한다. 만약 회귀모형이 상수항을 포함하여 올바르게 정의되었다면 잔차의 평균이 0이 된다. 즉 종속변수의 평균과 모형 예측값의 평균이 같아진다. \\bar{e} = \\bar{y} - \\bar{\\hat{y}} = 0 \\bar{y} = \\bar{\\hat{y}}그리고 이 분산값들 간에는 다음과 같은 관계가 성립한다. \\text{TSS} = \\text{ESS} + \\text{RSS}위 식이 말하는 바는 다음과 같다. 모형 예측치의 움직임의 크기(분산)은 종속변수의 움직임의 크기(분산)보다 클 수 없다. 모형의 성능이 좋을 수록 모형 예측치의 움직임의 크기는 종속변수의 움직임의 크기와 비슷해진다. example 123456789101112import numpyimport pandasfrom sklearn.datasets import make_regressionx0, y, coef = make_regression(n_samples=100, n_features=1, noise=30, coef=True, random_state=0)dfx0 = pd.DataFrame(x0, columns=[\"X\"])dfx = sm.add_constant(dfx0)dfy = pd.DataFrame(y, columns=[\"Y\"])df = pd.concat([dfx, dfy], axis=1)model = sm.OLS.from_formula(\"Y ~ X\", data=df)result = model.fit() 12345print(\"TSS = \", result.uncentered_tss)print(\"ESS = \", result.mse_model)print(\"RSS = \", result.ssr)print(\"ESS + RSS = \", result.mse_model + result.ssr)print(\"R squared = \", result.rsquared) 결정 계수(Coefficient of Determination) 위의 분산 관계식에서 모형의 성능을 나타내는 결정계수(Coefficient of Determination) $R^2$를 정의할 수 있다. R^2 \\equiv 1- \\dfrac{\\text{RSS}}{\\text{TSS}} = \\dfrac{\\text{ESS}}{\\text{TSS}}분산 관계식과 모든 분산값이 0보다 크다는 점을 이용하면 $R^2$의 값은 다음과 같은 조건을 만족한다. 0 \\leq R^2 \\leq 1여기에서 $R^2$가 0 이라는 것은 오차의 분산 RSS가 최대이고 회귀분석 예측값의 분산 ESS가 0인 경우이므로 회귀분석 결과가 아무런 의미가 없다는 뜻이다. 반대로 $R^2$가 1이라는 것은 오차의 분산 RSS가 0이고 회귀분석 예측의 분산 ESS가 TSS와 같은 경우이므로 회귀분석 결과가 완벽하다는 뜻이다. 따라서 결정계수값은 회귀분석의 성능을 나타내는 수치라고 할 수 있다. 분산 분석표 분산 분석의 결과는 보통 다음과 같은 분산 분석표를 사용하여 표시한다. 아래의 표에서 $N$은 데이터의 갯수, $K$는 모수(독립변수의 갯수, 상수항 포함)의 갯수를 뜻한다. source degree of freedom sum of square mean square F test-statistics p-value Regression $K -1$ $\\text{ESS}$ $s_\\hat{y}^2 = \\dfrac{\\text{ESS}}{K-1}$ $F = \\dfrac{s_\\hat{y}^2}{s_e^2}$ p-value Residual $N - K$ $\\text{RSS}$ $s_e^2 = \\dfrac{\\text{RSS}}{N-K}$ Total $N - 1$ $\\text{TSS}$ $s_y^2 = \\dfrac{\\text{TSS}}{N-1}$ $R^2$ $\\dfrac{\\text{ESS}}{\\text{TSS}}$ 결정 계수와 상관 계수 $y$와 $\\hat{y}$의 샘플 상관계수 $r$의 제곱은 결정 계수 $R^2$와 같다. 상수항이 없는 모형의 경우 모형에서 상수항을 지정하지 않은 경우에는 결정계수의 정의에 사용되는 TSS의 정의가 다음과 같이 달라진다. \\text{TSS} = \\sum_{i=1}^{N}y_i^2 = y^Ty즉, 실제 샘플평균과 상관없이 $\\bar{y} = 0$ 이라는 가정하에 TSS를 계산한다. 이렇게 정의하지 않으면 TSS = RSS + ESS 관계식이 성립하지 않아서 결정계수의 값이 1보다 커지게 된다. 따라서 모형의 결정계수를 비교할 때 상수항이 없는 모형과 상수항이 있는 모형은 직접 비교하면 안된다. F 검정을 이용한 모형 비교 F 검정을 이용하면 다음과 같이 포함관계에 있는 두 모형의 성능을 비교할 수 있다. 전체 모형(Full Model): y = w_0 + w_1x_1 + w_2x_2 + w_3x_3 축소 모형(Reduced Model): y = w_0 + w_1x_1 다음과 같은 귀무가설을 검정하는 것은 위의 두 모형이 실질적으로 같은 모형이라는 가설을 검정하는 것과 같다. H_0 : w_2 = w_3 = 0이 검정도 F검정을 사용하여 할 수 있다. StatsModels에서는 anova_lm명령에 두 모형의 result 객체를 인수로 넣어주면 이러한 검정을 할 수 있다. 인수를 넣어줄 때는 축소 모형(reduced model), 전체 모형(full model)의 순서로 넣어준다.","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Regression","slug":"Math/Regression","permalink":"https://p829911.github.io/categories/Math/Regression/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"}]},{"title":"Jupyber notebook matplotlib 한글 설정","slug":"Jupyber-notebook-matplotlib-한글-설정","date":"2018-11-26T13:25:40.000Z","updated":"2018-11-26T14:52:32.944Z","comments":true,"path":"2018/11/26/Jupyber-notebook-matplotlib-한글-설정/","link":"","permalink":"https://p829911.github.io/2018/11/26/Jupyber-notebook-matplotlib-한글-설정/","excerpt":"","text":"우분투 폰트 경로 /usr/share/fonts/ 나눔 글꼴 또는 다른 폰트도 /usr/share/fonts/ 폴더에 복사에서 사용가능하다. 나눔글꼴 설치 12sudo apt-get install fonts-nanum*sudo fc-cache -fv apt-get 명령으로 나눔글꼴 설치 후, fc-cache 명령으로 폰트 캐시 삭제 다른 ttf 폰트 12sudo cp new_font.ttf / usr/share/fontssudo fc-cache -fv 우분투 폰트 경로로 ttf폰트 복사 후, fc-cache 명령으로 폰트 캐시 삭제 matplotlib 폴더에 글꼴 추가 123sudo cp /usr/share/fonts/truetype/D2Coding/D2* /home/p829911/.local/lib/python3.6/site-packages/matplotlib/mpl-data/rm -rf /home/ubuntu/.cache/matplotlib/* matplotlib 폴더에 글꼴을 복사 한 후 matplotlib의 폰트 캐시를 삭제 12# 캐쉬 디렉토리matplotlib.get_cachedir() 내 컴퓨터에 저장되어 있는 폰트 리스트 가져오기 123456789import matplotlib.font_manager as fmfont_list = fm.findSystemFonts(fontpaths=None, fontext='ttf')# 전체개수print(len(font_list)) # 처음 10개만 출력font_list[:10] 사용가능한 시스템의 TTF 폰트 목록 123456import matplotlib.font_manager as fmfont_list = [(f.name, f.fname) for f in fm.fontManager.ttflist]print(len(font_list))font_list[:10] 내가 원하는 D2Coding 폰트의 저장 위치를 불러오기 123for font in font_list: if \"D2\" in font[0]: print(font) rcParams 를 설정 파일에 직접 적어주기 - 모든 노트북에 공통 적용 font.family: D2Coding 이곳에 폰트를 지정해 주면 노트북을 실행 할 때 바로 로드되도록 설정할 수 있다. 1print(matplotlib.matplotlib_fname()) 1vi /home/p829911/.local/lib/python3.6/site-packages/matplotlib/mpl-data/matplotlibrc matplotlibrc파일에서 font.family를 D2Coding으로 설정해준다. 1234567891011import numpy as npimport matplotlib.pyplot as plt%matplotlib inlinedata = np.random.randint(-100, 100, 50).cumsum()dataplt.plot(range(50), data, 'r')plt.title('가격변동 추이')plt.ylabel('가격')plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/categories/Python/"}],"tags":[{"name":"Jupyter","slug":"Jupyter","permalink":"https://p829911.github.io/tags/Jupyter/"},{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/tags/Python/"}]},{"title":"Jupyter notebook 글꼴 설정","slug":"Jupyter-notebook-글꼴-설정","date":"2018-11-26T10:51:23.000Z","updated":"2018-11-26T14:52:46.876Z","comments":true,"path":"2018/11/26/Jupyter-notebook-글꼴-설정/","link":"","permalink":"https://p829911.github.io/2018/11/26/Jupyter-notebook-글꼴-설정/","excerpt":"","text":"D2Coding 설치 12345cd /home/username/.jupytermkdir customcd customtouch custom.cssvi custom.css 만약 custom.css에 쓰기 권한이 없으면 chmod명령으로 파일 권한을 바꿔준다. 1sudo chmod 777 custom.css vi 편집기로 custom.css 파일을 연 후 다음과 같이 설정 해 준다. 1.CodeMirror pre &#123;font-family: D2Coding; font-size: 12pt; line-height: 120%;&#125; jupyter notebook을 실행하면 글꼴이 D2Coding으로 바뀐 것을 볼 수 있다.","categories":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/categories/Python/"}],"tags":[{"name":"Jupyter","slug":"Jupyter","permalink":"https://p829911.github.io/tags/Jupyter/"},{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/tags/Python/"}]},{"title":"git blog 관리하기","slug":"git-blog-관리하기","date":"2018-11-26T10:50:56.000Z","updated":"2018-11-28T12:57:41.039Z","comments":true,"path":"2018/11/26/git-blog-관리하기/","link":"","permalink":"https://p829911.github.io/2018/11/26/git-blog-관리하기/","excerpt":"","text":"새 저장소(repository) 만들기Github에서 새 저장소(repository)를 만든다. 이 때 저장소의 이름을 자신의 username뒤에 .github.io가 붙은 이름으로 만든다. 이렇게 만들어 줘야 username.github.io의 도메인으로 접속할 수 있는 블로그가 된다. Hexo 설치하기git과 node.js는 설치돼 있어야 한다. 12sudo apt install npmnpm install -g hexo-cli # 오류 날 시 앞에 sudo를 붙여준다 1hexo -v 위의 명령어로 hexo가 제대로 설치 되었는지 확인 한다. Hexo 설치가 완료되었으면 다음과 같은 명령어를 입력해서 Hexo 디렉토리를 초기화한다. 1hexo init &lt;디렉토리명&gt; 설치가 모두 잘 되었다면 다음 명령어를 입력해서 내장 서버를 돌릴 수 있다. 1hexo server 브라우저에서 http://0.0.0.0:4000/ 으로 접속해서 확인 할 수 있다. deployHexo가 설치된 디렉토리로 가서 _config.yml 파일을 열어 Site, URL, Deployment 항목을 수정해준다. 그리고 정적 파일을 생성한다. 1hexo generate 디플로이를 하기 위해서는 hexo-deployer-git 플러그인이 필요하다. 아래의 명령어를 사용해서 설치한다. 1npm install --save hexo-deployer-git 생성이 잘 되었다면 디플로이 명령어를 사용한다. 1hexo deploy Hueman 테마 적용하기블로그 루트 폴더에서 명령어로 테마를 받는다. 1git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman blog 폴더에 있는 _config.yml에서 Theme부분을 landscape에서 hueman으로 바꿔준다. themes/hueman 폴더에 있는 _config.yml.example을 _config.yml로 바꾼다. 12cd blog/themes/huemanmv _config.yml.example _config.yml 최신 버전을 다운받기 위해 pull해준다. 12cd themes/huemangit pull Hueman 테마의 Insight Search 검색엔진을 사용하기 위해 npm으로 hexo-generator-json-content을 설치한다. 1npm install -S hexo-generator-json-content hueman의 테마는 hueman폴더 안에 있는 _config.yml에서 설정할 수 있다. 포스트 작성하기1hexo new post \"post name\" 그러면 [blogFolder]/source/_posts에 새로운 마크다운 파일이 생성된다.자동으로 제목과 생성날짜가 들어간다. 글을 마크다운 파일로 작성 한 후 12hexo generatehexo deploy or 1hexo generate --deploy 테마가 적용 안되는 경우12hexo cleanhexo generate --deploy","categories":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/tags/Git/"},{"name":"Blog","slug":"Blog","permalink":"https://p829911.github.io/tags/Blog/"}]},{"title":"우분투 Root 비밀번호 설정","slug":"우분투-Root-비밀번호-설정","date":"2018-11-26T10:46:43.000Z","updated":"2018-11-26T11:07:04.086Z","comments":true,"path":"2018/11/26/우분투-Root-비밀번호-설정/","link":"","permalink":"https://p829911.github.io/2018/11/26/우분투-Root-비밀번호-설정/","excerpt":"","text":"우분투를 설치하면 기본으로 Root 비밀번호가 없는 상태이다. 아래와 같은 방법으로 root 비밀번호를 설정해본다. root 비밀번호 설정 1sudo passwd 위와 같이 비밀번호를 설정 했다면 1su 명령을 통해 root에 로그인 할 수 있다. passwd 1passwd 현재 로그인한 사용자 계정의 비밀번호를 변경할 수 있는 명령어이다. root에서 user 비밀번호 변경 1passwd p829911 root에서 p829911이라는 사용자의 비밀번호를 변경하고 싶을 때 사용하는 명렁어이다.","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"우분투 한글 입력기 설치","slug":"우분투-한글-입력기-설치","date":"2018-11-24T18:14:50.000Z","updated":"2018-11-24T18:51:55.876Z","comments":true,"path":"2018/11/25/우분투-한글-입력기-설치/","link":"","permalink":"https://p829911.github.io/2018/11/25/우분투-한글-입력기-설치/","excerpt":"","text":"한글 설치 fcitx-hangul 설치 1sudo apt-get install fcitx-hangul System Setting (설정) &gt; Language Support(언어 지원) 을 실행해서 설치되지 않은 언어팩 모두 설치한다. 키보드 입력기를 ibus에서 fcitx로 변경한다. 재부팅 시 오른쪽 위에 아래의 첫번째에서 보는 것과 같은 아이콘이 생성된 것을 볼 수 있다. 한영 변환 설정 &gt; 장치 &gt; 키보드 로 들어간 뒤 입력 중의 다음 입력소스로 전환, 이전 입력소스로 전환을 사용 않음으로 바꿔준다. 사용 않음으로 바꿔주기 위해선 클릭 후 backspace를 누르면 된다. 상단 메뉴바 오른쪽의 입력기 선택(위 그림에서 세번째) 후 현재 입력기 설정 클릭 Keyboard-English(US)가 있다면 + 를 눌러 Hangul을 추가한다. (uncheck “Only Show Current Language”). Korean이 아닌 Hangul을 선택한다. 전역 설정 &gt; 단축키 &gt; 입력기 전환에 ‘Shift + Space’를 추가한다. 전역 설정 &gt; 프로그램 윈도우 사이에 상태 공유를 ‘모두’로 바꿔준다","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"우분투 데이터분석 환경설정","slug":"우분투-데이터분석-환경설정","date":"2018-11-24T17:25:25.000Z","updated":"2018-11-24T18:12:21.696Z","comments":true,"path":"2018/11/25/우분투-데이터분석-환경설정/","link":"","permalink":"https://p829911.github.io/2018/11/25/우분투-데이터분석-환경설정/","excerpt":"","text":"우분투 버전: Ubuntu 18.04.1 LTS 이 글은 데이터 분석을 공부하면서 window 사용자가 우분투에 데이터 분석 환경 설정 하며 겪은 시행착오와 그 단계들을 모아둔 글입니다. 오류와 path충돌 때문에 눈물을 머금고 우분투를 4번 정도 다시 깔면서 다음에 다시 설치해야 할 상황이 왔을 때 참고하기 위한 글이고, 우분투로 처음 데이터 분석 환경 설정을 하려고 하는 분들을 위해 정리하는 글입니다. 이 포스트와 다음과 같은 내용이 포함되어 있습니다. 한글 입력기 설치 root 비밀번호 설정 패키지 관리 툴 apt 사용법 슬랙 설치 vim 설치 git 설치 python3 설치 및 기본 설정 python3 데이터 분석 관련 패키지 설치 markdown 편집기 typora 설치 Atom &amp; Atom package 설치 mysql &amp; mysql workbench 설치 AWS(Amazon Web Services) 가입 및 접속 AWS와 파일 주고 받기를 할 수 있는 FileZilla 설치 및 사용법","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]}]}
{"meta":{"title":"data science study blog","subtitle":"Data Science Study Blog","description":null,"author":"Seungwoo Hyun","url":"https://p829911.github.io"},"pages":[],"posts":[{"title":"그래프 확률 모형","slug":"그래프-확률-모형","date":"2019-01-16T12:54:47.000Z","updated":"2019-01-16T12:57:49.710Z","comments":true,"path":"2019/01/16/그래프-확률-모형/","link":"","permalink":"https://p829911.github.io/2019/01/16/그래프-확률-모형/","excerpt":"","text":"여러 확률변수의 결합분포를 구해야 하는 경우를 생각하자. 예를 들어 A, B, C, 3개의 확률변수가 있고 각 확률변수가 0, 1, 2 세가지의 값만 가질 수 있는 카테고리 확률변수인 경우 이 세 확률변수의 결합분포는 다음과 같이 표로 나타낼 수 있다. 이 표는 $3^3 - 1 = 26$ 개의 모수를 가지므로 (합이 1이 되어야 하므로 하나는 다른 값들에 의존한다.) 이 표를 저장하려면 26개의 저장 공간이 필요하다. A B C P(A, B, C) 0 0 0 P(A=0,B=0,C=0) 0 0 1 P(A=0,B=0,C=1) 0 0 2 P(A=0,B=0,C=2) 0 1 0 P(A=0,B=1,C=0) 0 1 1 P(A=0,B=1,C=1) 0 1 2 P(A=0,B=1,C=2) 0 2 0 P(A=0,B=2,C=0) 0 2 1 P(A=0,B=2,C=1) 0 2 2 P(A=0,B=2,C=2) 1 0 0 P(A=1,B=0,C=0) 1 0 1 P(A=1,B=0,C=1) 1 0 2 P(A=1,B=0,C=2) 1 1 0 P(A=1,B=1,C=0) 1 1 1 P(A=1,B=1,C=1) 1 1 2 P(A=1,B=1,C=2) 1 2 0 P(A=1,B=2,C=0) 1 2 1 P(A=1,B=2,C=1) 1 2 2 P(A=1,B=2,C=2) 2 0 0 P(A=2,B=0,C=0) 2 0 1 P(A=2,B=0,C=1) 2 0 2 P(A=2,B=0,C=2) 2 1 0 P(A=2,B=1,C=0) 2 1 1 P(A=2,B=1,C=1) 2 1 2 P(A=2,B=1,C=2) 2 2 0 P(A=2,B=2,C=0) 2 2 1 P(A=2,B=2,C=1) 2 2 2 P(A=2,B=2,C=2) 베이지안 네트워크 모형그런데 현실에서는 모든 확률변수가 서로 영향을 미치는 복잡한 경우 보다 특정한 몇개의 확률분포들이 서로 영향을 미친다. 예를 들어 A, B, C가 각각 어떤 학생의 A: 건강 상태 B: 공부 시간 C: 시험 성적 을 나타낸 것이라고 하자. 이 확률변수는 각각 $\\{0, 1, 2\\}$ 라는 값을 가질 수 있는데 하(0), 중(1), 상(2)의 상태를 나타낸다. 즉 $A = 0$이면 건강상태가 안좋은 것이고 $B = 1$ 이면 공부 시간이 보통이며 $C = 2$이면 시험 성적이 좋은 것이다. 공부 시간 $B$는 시험 성적 $C$에 영향을 미친다. 하지만 건강 상태 $A$는 공부 시간 $B$와 인과 관계가 있지만 시험 성적 $C$와는 직접적인 인과 관계가 없다. 이렇게 다수의 확률변수 중 특정한 소수의 확률변수들이 가지는 관계를 그래프로 표현한 것을 그래프 확률모형(graphical probability model)이라고 하고 그래프 확률모형 중에서도 이렇게 인과관계가 확실하여 방향성 그래프로 표시할 수 있는 것을 베이지안 네트워크 모형이라고 한다. 위의 확률변수를 베이지안 네트워크 모형으로 그리면 다음과 같다. 1234567891011import networkx as nxfrom IPython.core.display import Imagefrom networkx.drawing.nx_pydot import to_pydotg1 = nx.DiGraph()g1.add_path([\"A\", \"B\", \"C\"])d1 = to_pydot(g1)d1.set_dpi(300)d1.set_rankdir(\"LR\")d1.set_margin(0.2)Image(d1.create_png(), width=600) 이러한 그래프를 방향성 그래프(directed graph)라고 한다. 방향성 그래프에서 확률변수는 하나의 노드(node) 또는 정점(vertex)로 나타내고 인과관계는 화살표 간선(edge, link)으로 나타낸다. 우리가 다루는 방향성 그래프는 화살표가 여러 확률변수를 거쳐 자기 자신에게 돌아오는 루프(loop)가 없는 DAG(Directed Acyclic Graph) 모형이다. 방향성 그래프 모델에서는 원인과 결과가 되는 두 확률변수의 관계를 조건부 확률분포로 표현한다. 위의 모형에서처럼 A가 B의 원인이 된다면 이 두 확률변수의 관계를 $P(B \\mid A)$ 로 나타내고 B가 C의 원인이 되므로 두 확률변수의 관계는 $P(C \\mid B)$ 로 나타낸다. 그리고 전체 확률변수들간의 관계는 이러한 조건부 확률분포를 결합하여 나타낼 수 있다. 위의 그래프에서 전체 결합분포는 다음과 같다. P(A, B, C) = P(A)P(B \\mid A)P(C \\mid B)단, 여기에서 유의해야 할 점은 A와 B는 직접적인 인과 관계가 없지만 상관관계는 있을 수 있다는 점이다. 예를 들어 A-B, B-C간의 관계가 모두 양의 상관관계면 A가 커졌을 때 B도 커지고 따라서 C도 커지므로 A와 B가 양의 상관관계를 가지게 된다. A, B, C가 의미하는 바로 해석하면 건강 상태와 시험 성적은 직접적인 인과관계는 없지만 건강상태가 좋을 때 공부 시간도 많아질 가능성이 높고 공부 시간이 많을 때 시험 성적이 좋아진다면 건강 상태와 시험 성적은 양의 상관관계를 가질 수 있다. 결합확률분포를 이루는 팩터를 각각 표로 나타내면 다음과 같다. A 𝑃(𝐴) A=0 𝑃(𝐴=0)P(A=0) A=1 𝑃(𝐴=1)P(A=1) A=2 𝑃(𝐴=2)P(A=2) B 𝑃(𝐵\\ 𝐴=0) 𝑃(𝐵\\ 𝐴=1) 𝑃(𝐵\\ 𝐴=2) B=0 𝑃(𝐵=0\\ 𝐴=0)P(B=0\\ A=0) 𝑃(𝐵=0\\ 𝐴=1)P(B=0\\ A=1) 𝑃(𝐵=0\\ 𝐴=2)P(B=0\\ A=2) B=1 𝑃(𝐵=1\\ 𝐴=0)P(B=1\\ A=0) 𝑃(𝐵=1\\ 𝐴=1)P(B=1\\ A=1) 𝑃(𝐵=1\\ 𝐴=2)P(B=1\\ A=2) B=2 𝑃(𝐵=2\\ 𝐴=0)P(B=2\\ A=0) 𝑃(𝐵=2\\ 𝐴=1)P(B=2\\ A=1) 𝑃(𝐵=2\\ 𝐴=2)P(B=2\\ A=2) C 𝑃(𝐶\\ 𝐵=0) 𝑃(𝐶\\ 𝐵=1) 𝑃(𝐶\\ 𝐵=2) C=0 𝑃(𝐶=0\\ 𝐵=0)P(C=0\\ B=0) 𝑃(𝐶=0\\ 𝐵=1)P(C=0\\ B=1) 𝑃(𝐶=0\\ 𝐵=2)P(C=0\\ B=2) C=1 𝑃(𝐶=1\\ 𝐵=0)P(C=1\\ B=0) 𝑃(𝐶=1\\ 𝐵=1)P(C=1\\ B=1) 𝑃(𝐶=1\\ 𝐵=2)P(C=1\\ B=2) C=2 𝑃(𝐶=2\\ 𝐵=0)P(C=2\\ B=0) 𝑃(𝐶=2\\ 𝐵=1)P(C=2\\ B=1) 𝑃(𝐶=2\\ 𝐵=2) 이 경우에 우리가 알아야 하는 모수의 수는 $P(A): 3- 1 = 2$ $P(B \\mid A): (3-1) \\times 2 = 6$ $P(C \\mid B): (3-1) \\times 2 = 6$ 따라서 총 14개이다. 변수간의 인과 관계라는 추가 정보로 인해 모수의 숫자가 26개에서 14개로 크게 감소하였다. 이렇게 우리가 알고 있는 확률변수간의 정보를 그래프를 이용하여 추가하면 문제를 더 간단하게 만들 수 있다. pgmpy 패키지를 사용하여 앞의 예제를 파이썬으로 구현해 보자. 조건부 확률 $P(A), P(B \\mid A), P(C \\mid B)$ 는 TabularCPD 클래스로 다음과 같이 구현할 수 있다. 우선 건강 상태는 나쁠(A=0) 확률이 20%, 보통(A=1)일 확률이 60%, 좋을 확률이 20%라고 하자. 1234from pgmpy.factors.discrete import TabularCPDP_A = TabularCPD('A', 3, [[0.2, 0.6, 0.2]])print(P_A) 건강 상태가 나쁘면(A=0), 공부시간이 적거나(B=0), 보통이거나(B=1), 많을(B=2) 확률은 각각 50%, 30%, 20%이다. 건강 상태가 보통이면(A=1), 공부시간이 적거나(B=0), 보통이거나(B=1), 많을(B=2) 확률은 각각 20%, 60%, 20%이다. 건강 상태가 좋으면(A=2), 공부시간이 적거나(B=0), 보통이거나(B=1), 많을(B=2) 확률은 각각 20%, 30%, 50%이다. 1234P_B_I_A = TabularCPD('B', 3, np.array([[0.6, 0.2, 0.2], [0.3, 0.5, 0.2], [0.1, 0.3, 0.6]]), evidence=['A'], evidence_card=[3])print(P_B_I_A) 비슷하게 공부시간이 적으면(B=0), 성적이 나쁘거나(C=0), 보통이거나(C=1), 좋을(C=2) 확률은 각각 80%, 10%, 10%이다. 공부시간이 보통이면(B=1), 성적이 나쁘거나(C=0), 보통이거나(C=1), 좋을(C=2) 확률은 각각 10%, 80%, 10%이다. 공부시간이 많으면(B=2), 성적이 나쁘거나(C=0), 보통이거나(C=1), 좋을(C=2) 확률은 각각 10%, 10%, 80%이다. 1234P_C_I_B = TabularCPD('C', 3, np.array([[0.8, 0.1, 0.1], [0.1, 0.8, 0.1], [0.1, 0.1, 0.8]]), evidence=['B'], evidence_card=[3])print(P_C_I_B) 이 조건부 확률들을 결합하여 하나의 베이지안 네트워크로 만들려면 BayesianModel 클래스를 사용한다. 생성자에는 노드를 연결한 그래프 정보를 넣고 add_cpds 메서드로 조건부확률을 추가할 수 있다. 1234567from pgmpy.models import BayesianModelmodel = BayesianModel([('A', 'B'), ('B', 'C')])model.add_cpds(P_A, P_B_I_A, P_C_I_B)model.check_model()# True graphviz와 pydot 패키지를 사용하여 시각화 할 수도 있다. 12345678from IPython.core.display import Imagefrom networkx.drawing.nx_pydot import to_pydotd = to_pydot(model)d.set_dpi(300)d.set_margin(0.2)d.set_rankdir(\"LR\")Image(d.create_png(), width=600) 이렇게 만들어진 모형으로부터 여러가지 추론(inference)을 할 수 있다. 예를 들어 전체 결합확률분포 함수를 찾고 그 함수로부터 A, B, C의 marginal 확률분포를 계산하면 A, B, C의 값으로 어떤 값이 가장 확률이 높은지 알 수 있다. 분석 결과를 보면 시험 성적이 좋을 확률은 35.9%이다. 추론에 사용된 VariableElimination 클래스의 사용법에 대해서는 곧 학습한다. 1234from pgmpy.inference import VariableEliminationinference = VariableElimination(model)result = inference.query(variables=[\"C\"])print(result[\"C\"]) 베이지안 네트워크의 결합확률분포베이지안 네트워크를 만들려면 조사 대상이 되는 확률변수를 노드(node)로 생성하고 인과관계가 있는 노드를 방향성 간선(directed edge)로 연결하는 것이다. 이렇게 베이지안 네트워크가 만들어지면 이 확률변수들의 결합확률분포는 다음처럼 주어진다. P(X_1, \\cdots, X_N) = \\prod_{i=1}^N P(X_i \\mid Pa(X_i))이 식에서 $Pa(X_i)$ 는 $X_i$ 의 부모 노드이다. 1234567891011121314g1 = nx.DiGraph()g1.add_edge(\"X1\", \"X3\")g1.add_edge(\"X1\", \"X4\")g1.add_edge(\"X3\", \"X4\")g1.add_edge(\"X2\", \"X4\")g1.add_edge(\"X2\", \"X7\")g1.add_edge(\"X4\", \"X5\")g1.add_edge(\"X4\", \"X6\")d1 = to_pydot(g1)d1.set_dpi(300)d1.set_margin(0.2)d1.set_rankdir(\"LR\")Image(d1.create_png(), width=800) 예를 들어 $X_1, \\cdots, X_6$ 의 관계가 앞 그래프와 같다면 결합확률분포는 다음과 같다. P(X_1, X_2, X_3, X_4, X_5, X_6, X_7) = \\\\ P(X_1)P(X_2)P(X_3 \\mid X_1)P(X_4 \\mid X_2,X_3)p(X_5 \\mid X_4)P(X_6 \\mid X_4)P(X_7 \\mid X_2)조건부 독립베이지안 네트워크를 만들 때 중요한 것은 확률변수간의 조건부 독립 관계가 그래프에 나타나고 있어야 한다는 점이다. 조건부 독립(conditional independence)은 일반적인 독립과 달리 조건이 되는 확률변수가 존재해야 한다. 일반적으로는 확률변수 A, B가 독립인 정의는 다음과 같다. P(A, B) = P(A)P(B)조건부 독립은 조건이 되는 C라는 확률변수에 대한 조건부 결합확률분포에 대해 다음이 만족되어야 한다. P(A, B \\mid C) = P(A \\mid C) P(B \\mid C)즉, C에 대한 조건부 결합확률분포가 조건부 확률분포의 곱으로 나타난다. 기호로는 다음과 같이 표기한다. A \\text{⫫} B \\;\\vert\\; C같은 방식으로 무조건부 독립은 다음과 같이 표기하기도 한다. A \\text{⫫} B \\; \\vert\\; \\emptysetA, B가 C에 대해 조건부 독립이면 다음도 만족한다. P(A \\mid B, C) = P(A \\mid C)\\\\ P(B \\mid A, C) = P(B \\mid C)주의할 점은 조건부 독립과 (무조건부) 독립은 관계가 없다는 점이다. 즉, 두 확률변수가 독립이라고 항상 조건부 독립이 되는 것도 아니고 조건부 독립이라고 꼭 독립이 되는 것도 아니다. P(A, B) = P(A)P(B) \\;\\; \\bcancel{\\implies} \\;\\; P(A,B \\mid C) = P(A \\mid C)P(B \\mid C) \\\\ P(A,B \\mid C) = P(A \\mid C)P(B \\mid C) \\;\\; \\bcancel{\\implies} \\;\\; P(A, B) = P(A)P(B)방향성 분리방향성 분리(d-separation, directed separation) 정리는 방향성 그래프 모형에서 어떤 두 노드(확률변수)가 조건부 독립인지 아닌지 알아보는 방법이다. 다음과 같은 세가지 간선 결합을 알아야 한다. 꼬리-꼬리 결합 머리-꼬리 결합 머리-머리 결합 꼬리-꼬리 결합우선 다음과 같이 확률변수 A, B가 공통의 부모 C를 가지는 경우를 보자. C에서는 간선(화살표)의 꼬리가 2개 붙어 있기 때문에 C는 꼬리-꼬리(tail-to-tail) 결합이라고 한다. 1234567g2 = nx.DiGraph()g2.add_path([\"C\", \"A\"])g2.add_path([\"C\", \"B\"])d2 = to_pydot(g2)d2.set_dpi(300)d2.set_margin(0.2)Image(d2.create_png(), width=400) 이 때 A와 B는 독립은 아니지만 조건부 독립이 성립한다. P(A,B \\mid C) = \\dfrac{P(A, B, C)}{P(C)} = \\dfrac{P(A \\mid C)P(B \\mid C)P(C)}{P(C)} = P(A \\mid C)P(B \\mid C)이런 상태를 C가 A, B 사이를 막고있다(block)고 한다. 머리-꼬리 결합다음으로는 인과관계인 확률변수 A, B 사이에 C가 끼어 있는 경우를 살펴보자. 이때 노드 C에서 간선의 머리와 꼬리가 만나기 때문에 머리-꼬리(head-to-tail) 결합이라고 한다. 1234567g3 = nx.DiGraph()g3.add_path([\"A\", \"C\", \"B\"])d3 = to_pydot(g3)d3.set_dpi(300)d3.set_rankdir(\"LR\")d3.set_margin(0.2)Image(d3.create_png(), width=600) 이 경우에도 A와 B는 독립이 아니지만 조건부 독립이 성립한다. P(A,B|C) = \\dfrac{P(A, B, C)}{P(C)} = \\dfrac{P(A)P(C|A)P(B|C)}{P(C)} = \\dfrac{P(A,C)P(B|C)}{P(C)} = P(A|C)P(B|C)위의 경우와 마찬가지로 C가 A, B 사이를 막고(block) 있다고 한다. 머리-머리 결합마지막으로 두 확률변수 A, B를 부모로 가지는 C가 있는 경우를 살펴보자. 이러한 구조는 V-구조(V-structure) 또는 머리-머리(head-to-head) 결합이라고 한다. 1234567g4 = nx.DiGraph()g4.add_path([\"A\", \"C\"])g4.add_path([\"B\", \"C\"])d4 = to_pydot(g4)d4.set_dpi(300)d4.set_margin(0.2)Image(d4.create_png(), width=400) 이 경우에는 앞의 두 경우와 달리 A와 B가 독립이다. P(A,B,C) = P(A)P(B)P(C|A,B) \\\\ P(A,B) = \\sum_c P(A)P(B)P(C|A,B) = P(A)P(B)하지만 조건부 독립은 성립하지 않는다. 예를 들어 A가 늦잠을 자는 것을 나타내는 확률변수, B가 길이 막히는 것을 나타내는 확률변수, C가 지각하는 것을 나타내는 확률변수라고 할 때, 늦잠을 자는 것과 길이 막히는 것은 서로 독립이다. 하지만 일단 지각(C)이 발생한 상황에서는 A, B는 서로 독립이 아니며 이 경우에는 반-상관관계를 가진다. 즉, 늦잠을 자지 않았다면 길이 막혔을 가능성이 높아지고 길이 막히지 않았다면 늦잠을 잤을 가능성이 높아진다. 이러한 것을 explaining-out이라고 한다. 이러한 상황은 C가 A, B의 직접적 자식이 아니라 후손(descendent)인 경우에도 성립한다. 12345678g5 = nx.DiGraph()g5.add_path([\"A\", \"D\"])g5.add_path([\"B\", \"D\"])g5.add_path([\"D\", \"C\"])d5 = to_pydot(g5)d5.set_dpi(300)d5.set_margin(0.2)Image(d5.create_png(), width=400) 이상의 상황을 정리한 것이 바로 방향성 분리(d-separation) 정리이다. 방향성 분리(d-separation) 정리에 따르면 A와 B가 C에 대해서 조건부 독립인 경우는 다음 조건이 만족되어야 한다 C가 A, B 사이의 경로에 있는 꼬리-꼬리 결합이거나 머리-꼬리 결합이다. C가 A, B 사이의 경로상에 있는 머리-머리 결합 노드 혹은 그 자손이 아니어야 한다. 마코프 네트워크때로는 변수간의 인과관계가 순환(cycle)관계를 이루기 때문에 방향성이 있는 베이지안 네트워크로 구현할 수 없는 경우도 있다. 이 때는 무방향성 그래프(undirected graph)인 마코프 네트워크(Markov network)를 사용한다. 마코프 무작위장(Markov random field)라고도 한다. 예를 들어 3 X 3 이미지의 픽셀 9개의 값이 확률변수라고 하면 이 4개의 확률변수 중 어떤 2개도 서로 관련성을 가진다. 이 때는 다음과 같은 마코프 네트워크를 사용할 수 있다. 12345678910111213141516171819202122import networkx as nxfrom IPython.core.display import Imagefrom networkx.drawing.nx_pydot import to_pydotg1 = nx.Graph()g1.add_edge(\"X11\", \"X12\")g1.add_edge(\"X11\", \"X21\")g1.add_edge(\"X12\", \"X22\")g1.add_edge(\"X12\", \"X13\")g1.add_edge(\"X21\", \"X31\")g1.add_edge(\"X21\", \"X22\")g1.add_edge(\"X22\", \"X23\")g1.add_edge(\"X22\", \"X32\")g1.add_edge(\"X31\", \"X32\")g1.add_edge(\"X32\", \"X33\")g1.add_edge(\"X13\", \"X23\")g1.add_edge(\"X23\", \"X33\")d1 = to_pydot(g1)d1.set_dpi(300)d1.set_margin(0.5)d1.set_rankdir(\"LR\")Image(d1.create_png(), width=600) 클리크와 팩터마코프 네트워크는 클리크(clique)로 구성되는데 클리크를 구성하는 확률변수의 분포는 포텐셜 함수(potential function)또는 팩터(factor)로 표현할 수 있다. 팩터는 결합확률분포에 양의 상수를 곱한 함수이다. 결합확률분포에 비례하지만 모든 확률을 더해서 1이 되어야 한다는 조건이 없다. 마코프 네트워크의 확률분포마코프 네트워크의 결합확률분포는 마코프 네트워크를 구성하는 모든 클리크의 팩터의 곱으로 나타난다. P(X) = \\dfrac{1}{Z(X)} \\prod_{\\{C\\}} \\psi_C(X_C)이 식에서 $C$는 클리크, $X_C$ 는 그 클리크 안의 확률변수, $\\psi_C$ 는 그 클리크의 팩터, $\\{C\\}$ 는 모든 클리크의 집합, $Z$ 는 파티션 함수(partition)함수를 나타낸다. 예를 들어 3 X 3 이미지의 경우 9개의 확률변수의 결합확률분포는 다음처럼 표현할 수 있다. P(X_{11}, \\ldots, X_{33}) = \\dfrac{1}{Z} \\prod \\psi(X_{11}, X_{12}) \\psi(X_{11}, X_{21}) \\psi(X_{12}, X_{13}) \\cdots \\psi(X_{23}, X_{33}) \\psi(X_{32}, X_{33})에너지 함수팩터 함수는 다음과 같은 형태로 표시할 수 있다. \\psi(X) = \\exp(−E(X))이 식에서 $E(X)$ 를 에너지 함수(energy function)라고 한다. 확률이 높을수록 에너지 함수의 값은 작아진다. 예를 들어 0과 1이라는 값을 가지는 베르누이 확률변수 $X_1, X_2$가 다음과 같은 에너지 함수로 표현되는 경우, E(X_1, X_2) = -3(2X_1 - 1)(2X_2 - 1)팩터의 값을 구하면 \\psi(X_1 = 1, X_2 = 1) = e^3 \\\\ \\psi(X_1 = 0, X_2 = 0) = e^3 \\\\ \\psi(X_1 = 1, X_2 = 0) = e^{-3} \\\\ \\psi(X_1 = 0, X_2 = 1) = e^{-3} \\\\즉 $X_1, X_2$ 둘 다 같은 값을 가질 확률은 서로 다른 값을 가질 확률에 비해 높아진다. 즉 서로 양의 상관관계를 가지게 된다. pgmpy에서는 MarkovModel 클래스로 마코프 네트워크 모형을 구현한다. 12345678910111213141516171819202122from pgmpy.models import MarkovModeln = 3ginfo = []for i in range(n): for j in range(n): if j &lt; n - 1: v1 = \"X&#123;&#125;&#123;&#125;\".format(i + 1, (j + 1)) v2 = \"X&#123;&#125;&#123;&#125;\".format(i + 1, (j + 2)) ginfo.append((v1, v2)) if i &lt; n - 1: v1 = \"X&#123;&#125;&#123;&#125;\".format(i + 1, (j + 1)) v2 = \"X&#123;&#125;&#123;&#125;\".format(i + 2, (j + 1)) ginfo.append((v1, v2)) model = MarkovModel(ginfo)d = to_pydot(model)d.set_dpi(300)d.set_margin(0.2)d.set_rankdir(\"LR\")Image(d.create_png(), width=600) 팩터는 DiscreteFactor 클래스로 구현할 수 있다. 예를 들어 $X_{11}, X_{12}$ 의 팩터 함수가 𝑋12=0 𝑋12=1 𝑋11=0 10 1 𝑋11=1 1 10 이면 다음처럼 구현한다. 12345from pgmpy.factors.discrete import DiscreteFactorfactor = DiscreteFactor(['X11', 'X12'], cardinality=[2, 2], values=[[10, 1], [1, 10]])model.add_factors(factor) 이미지 완성마코프 네트워크의 예로 다음과 같은 두 종류의 5 X 5 이미지 데이터를 생각하자. 12345678910111213141516171819202122n_char = 2images = np.zeros((n_char, 5, 5))idx = []idx.append(np.array([ (0, 1), (0, 2), (0, 3), (1, 0), (1, 4), (2, 0), (2, 2), (2, 4), (3, 0), (3, 4), (4, 1), (4, 2), (4, 3), ]))idx.append(np.array([ (0, 0), (0, 4), (1, 1), (1, 3), (2, 2), (3, 1), (3, 3), (4, 0), (4, 4),]))for k, idx in enumerate(idx): for i, j in idx: images[k, i, j] = 1plt.figure(figsize=(6, 2))for i in range(n_char): plt.subplot(1, n_char, i + 1) plt.imshow(images[i], cmap=plt.cm.bone_r) plt.grid(False) plt.xticks(()) plt.yticks(()) plt.title(i) 다음과 같이 팩터 함수를 학습한다. 1234567891011121314151617181920212223242526272829303132333435363738394041from pgmpy.models import MarkovModelfrom pgmpy.factors.discrete import DiscreteFactordef get_factor(v1, v2, idx1, idx2): p00 = p01 = p10 = p11 = 0 for k in range(num_images): if images[k, idx1[0], idx1[1]] == 0 and images[k, idx2[0], idx2[1]] == 0: p00 += 1 if images[k, idx1[0], idx1[1]] == 0 and images[k, idx2[0], idx2[1]] == 1: p01 += 1 if images[k, idx1[0], idx1[1]] == 1 and images[k, idx2[0], idx2[1]] == 0: p10 += 1 if images[k, idx1[0], idx1[1]] == 1 and images[k, idx2[0], idx2[1]] == 1: p11 += 1 factor = DiscreteFactor([v1, v2], cardinality=[2, 2], values=[[p00, p01], [p10, p11]]) return factormodel = MarkovModel()num_images = images.shape[0]n1 = images.shape[1]n2 = images.shape[2]for i in range(n1): for j in range(n2): if j &lt; n2 - 1: v1 = \"X&#123;&#125;&#123;&#125;\".format(i + 1, (j + 1)) v2 = \"X&#123;&#125;&#123;&#125;\".format(i + 1, (j + 2)) model.add_edge(v1, v2) factor = get_factor(v1, v2, (i, j), (i, j + 1)) model.add_factors(factor) if i &lt; n1 - 1: v1 = \"X&#123;&#125;&#123;&#125;\".format(i + 1, (j + 1)) v2 = \"X&#123;&#125;&#123;&#125;\".format(i + 2, (j + 1)) model.add_edge(v1, v2) factor = get_factor(v1, v2, (i, j), (i + 1, j)) model.add_factors(factor)model.check_model()# True 학습된 팩터의 일부를 살펴보자. 일례로 $X_{11}$ 과 $X_{12}$ 의 결합확률 팩터는 다음과 같다. 1234f = model.get_factors(\"X11\")[0]f# &lt;discretefactor representing phi(x11:2, x12:2) at 0x7f3b741f2c18&gt; 1print(f) 다음은 전체 네트워크 모양이다. 12345d = to_pydot(model)d.set_dpi(300)d.set_margin(0.2)d.set_rankdir(\"LR\")Image(d.create_png(), width=600) 다음 코드는 이미지의 일부를 알고 있을 때 나머지 이미지를 추정한 결과이다. 코드에서 evidence는 관측된 이미지의 일부이다. 여기에서 사용하는 BeliefPropagation 클래스는 다음 절에서 공부한다. 12345678910111213141516171819202122232425262728293031323334353637from pgmpy.inference import BeliefPropagationinference = BeliefPropagation(model)vars = []for i in range(n1): for j in range(n2): vars.append(\"X&#123;&#125;&#123;&#125;\".format(i + 1, j + 1))evidence1 = &#123; \"X11\": 0, \"X21\": 1, \"X31\": 1, \"X41\": 1, \"X51\": 0, \"X15\": 0, \"X25\": 1, \"X35\": 1, \"X45\": 1, \"X55\": 0,&#125;evidence2 = &#123; \"X11\": 1, \"X21\": 0, \"X31\": 0, \"X41\": 0, \"X51\": 1, \"X15\": 1, \"X25\": 0, \"X35\": 0, \"X45\": 0, \"X55\": 1,&#125;evidence = evidence1for x in evidence: vars.remove(x) result = inference.map_query(variables=vars, evidence=evidence)result.update(evidence)image = np.zeros((n1, n2))for i in range(n1): for j in range(n2): image[i, j] = result[\"X&#123;&#125;&#123;&#125;\".format(i + 1, j + 1)]print(image)[[0. 1. 1. 1. 0.] [1. 0. 0. 0. 1.] [1. 0. 1. 0. 1.] [1. 0. 0. 0. 1.] [0. 1. 1. 1. 0.]]","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Network","slug":"Math/Network","permalink":"https://p829911.github.io/categories/Math/Network/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Unsupervised Learning","slug":"Unsupervised-Learning","permalink":"https://p829911.github.io/tags/Unsupervised-Learning/"},{"name":"Network","slug":"Network","permalink":"https://p829911.github.io/tags/Network/"}]},{"title":"주식 가격","slug":"주식-가격","date":"2019-01-16T11:49:35.000Z","updated":"2019-01-16T11:51:39.620Z","comments":true,"path":"2019/01/16/주식-가격/","link":"","permalink":"https://p829911.github.io/2019/01/16/주식-가격/","excerpt":"","text":"문제 설명초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 유지된 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요. 제한사항 prices의 각 가격은 1 이상 10,000 이하인 자연수입니다. prices의 길이는 2 이상 100,000 이하입니다. 입출력 예 prices return [498,501,470,489] [2,1,1,0] 입출력 예 설명 1초 시점의 ₩498은 2초간 가격을 유지하고, 3초 시점에 ₩470으로 떨어졌습니다. 2초 시점의 ₩501은 1초간 가격을 유지하고, 3초 시점에 ₩470으로 떨어졌습니다. 3초 시점의 ₩470은 최종 시점까지 총 1초간 가격이 떨어지지 않았습니다. 4초 시점의 ₩489은 최종 시점까지 총 0초간 가격이 떨어지지 않았습니다. 나의 풀이12345678910def solution(prices): ls = [] for i, price in enumerate(prices): cnt = 0 for p in prices[i+1:]: cnt += 1 if price &gt; p: break ls.append(cnt) return ls 효율성 줄이기 실패…정답12345678910def solution(prices): answer = [0] * len(prices) for i in range(len(prices)-1): for j in range(i, len(prices)-1): if prices[i] &gt; prices[j]: break else: answer[i] +=1 return answer 출처 나의 풀이에는 for의 iterator에 list의 값을 넣었지만정답은 인덱스 만을 이용하여 price list를 건드리지 않고 값을 뽑아내어 풀었다.또한 list에 추가하는 것보다는 리스트의 값을 바꾸는 방식으로 효율성을 높인 것 같다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/tags/Algorithm/"}]},{"title":"문자열 내 마음대로 정렬하기","slug":"문자열-내-마음대로-정렬하기","date":"2019-01-16T11:19:39.000Z","updated":"2019-01-16T11:20:35.896Z","comments":true,"path":"2019/01/16/문자열-내-마음대로-정렬하기/","link":"","permalink":"https://p829911.github.io/2019/01/16/문자열-내-마음대로-정렬하기/","excerpt":"","text":"문제 설명문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [“sun”, “bed”, “car”]이고 n이 1이면 각 단어의 인덱스 1의 문자 “u”, “e”, “a”로 strings를 정렬합니다. 제한 조건 strings는 길이 1 이상, 50이하인 배열입니다. strings의 원소는 소문자 알파벳으로 이루어져 있습니다. strings의 원소는 길이 1 이상, 100이하인 문자열입니다. 모든 strings의 원소의 길이는 n보다 큽니다. 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다. 입출력 예 strings n return [“sun”,”bed”,”car”] 1 [“car”,”bed”,”sun”] [“abce”,”abcd”,”cdx”] 2 [“abcd”,”abce”,”cdx”] 입출력 예 설명입출력 예 1“sun”, “bed”, “car”의 1번째 인덱스 값은 각각 “u”, “e”, “a” 입니다. 이를 기준으로 strings를 정렬하면 [“car”, “bed”, “sun”] 입니다. 입출력 예 2“abce”와 “abcd”, “cdx”의 2번째 인덱스 값은 “c”, “c”, “x”입니다. 따라서 정렬 후에는 “cdx”가 가장 뒤에 위치합니다. “abce”와 “abcd”는 사전순으로 정렬하면 “abcd”가 우선하므로, 답은 [“abcd”, “abce”, “cdx”] 입니다. 나의 풀이 1123def solution(strings, n): answer = sorted(sorted(strings), key=lambda x: x[n]) return answer","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/tags/Algorithm/"}]},{"title":"체육복","slug":"체육복","date":"2019-01-15T14:15:29.000Z","updated":"2019-01-15T14:17:21.455Z","comments":true,"path":"2019/01/15/체육복/","link":"","permalink":"https://p829911.github.io/2019/01/15/체육복/","excerpt":"","text":"문제 설명오늘은 체육수업이 있는 날입니다. 그런데 점심시간에 도둑이 들어 몇몇 학생의 체육복이 도난을 당했습니다. 다행히 일부 학생들이 여벌의 체육복을 가져왔습니다. 학생들의 번호는 체격 순으로 매겨져 있기 때문에 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려주려고 합니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 당연히 체육복을 2벌 가져온 학생의 체육복이 도난을 당했다면, 여벌의 체육복을 빌려줄 수 없습니다. 체육복이 없으면 체육수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 듣고 싶습니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 2명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 입출력 예 n lost reserve return 5 [2,4] [1,3,5] 5 5 [2,4] [3] 4 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 1123456789101112def solution(n, lost, reserve): dup = set(lost) &amp; set(reserve) lost = list(set(lost) - dup) reserve = list(set(reserve) - dup) a = [i-1 for i in lost] b = [i+1 for i in lost] c = set(reserve) &amp; (set(a) | set(b)) num = len(lost) - len(c) if num &lt; 0: return n else: return n - num 21234567891011def solution(n, lost, reserve): dup = set(lost) &amp; set(reserve) lost = list(set(lost) - dup) reserve = list(set(reserve) - dup) for i in reserve: if i-1 in lost: lost.remove(i-1) continue elif i+1 in lost: lost.remove(i+1) return n - len(lost) comment문제를 정확히 읽고 제출하기 전에 충분히 검토해보고 제출하기.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/tags/Algorithm/"}]},{"title":"K번째수","slug":"K번째수","date":"2019-01-14T17:10:10.000Z","updated":"2019-01-16T12:11:08.546Z","comments":true,"path":"2019/01/15/K번째수/","link":"","permalink":"https://p829911.github.io/2019/01/15/K번째수/","excerpt":"","text":"문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 array commands return [1,5,2,6,3,7,4] [[2,5,3],[4,4,1],[1,7,3]] [5,6,3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다 [1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다. [1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 나의 풀이123456array = [1,5,2,6,3,7,4]commands = [ [2,5,3], [4,4,1], [1,7,3],] 12345def solution(array, commands): answer = [] for command in commands: answer.append(sorted(array[command[0]-1:command[1]])[command[2]-1]) return answer 다른 사람의 풀이12def solution(array, commands): return list(map(lambda x:sorted(array[x[0]-1:x[1]])[x[2]-1], commands)) lambda(람다) 함수lambda 함수는 익명함수로 메모리를 절약하는 이점이 있다.일반적인 함수는 객체를 만들고, 재사용을 위해 함수 이름(메모리)를 할당 한다. 123456# lambda 인수1, 인수2, ...: 인수를 이용한 표현식sum = lambda a, b: a + bresult = sum(3,4)print(result)# 7 익명함수이기 때문에 한번 쓰이고 다음줄로 넘어가면 힙(heap) 메모리 영역에서 증발하게 된다.자세하게 설명하자면 파이썬에서 모든 것이 객체로 관리되고 각 객체는 레퍼런스 카운터를 갖게 되는데 해당 카운터가 0 - 어떤 것도 참조를 하지 않으면 메모리를 환원한다 - 이러한 역할을 하는 것이 가비지 컬럭터이다. map 함수내장함수이며 입력받은 자료형의 각 요소가 함수에 의해 수행된 결과를 묶어서 map iterator 객체로 반환한다. map 함수는 게으른 연산을 진행해서 메모리를 크게 절약할 수 있다. 게으른 연산을 진행하기 때문에 값을 한번 사용했던 값은 다시 호출할 수가 없다. 1234567# map(function, iterable)# 예시li = [1,2,3]result = list(map(lambda i: i ** 2, li))print(result)# [1,4,9] 게으른 연산이란(lazy evaluation)?필요할 때만 가져다 사용한다. 보통 iterator 객체들이 게으른 함수이다. iterator 객체 next() 메소드로 데이터를 순차적으로 호출 가능 마지막 데이터 이후 next()를 호출하면 StopIteration 에러 발생 for 문을 사용할 때, 파이썬 내부에서는 임시로 list를 iterator로 변환해서 사용","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/tags/Algorithm/"}]},{"title":"pyenv, virtualenv, autoenv","slug":"pyenv-virtualenv-autoenv","date":"2019-01-14T17:01:17.000Z","updated":"2019-01-14T17:02:14.314Z","comments":true,"path":"2019/01/15/pyenv-virtualenv-autoenv/","link":"","permalink":"https://p829911.github.io/2019/01/15/pyenv-virtualenv-autoenv/","excerpt":"","text":"pyenv 파이썬 버전을 관리하는 툴 하나의 컴퓨터에 다양한 파이썬 버전을 설치하고 관리 pyenv-virtualenv virtualenv은 파이썬 환경을 격리하는 툴 pyenv-virtualenv은 virtualenv의 pyenv 확장 플러그인 파이썬 버전과 라이브러리의 완전한 격리 환경을 제공 autoenv autoenv는 디렉터리 이동 시 실행되는 스크립트 pyenv-virtualenv 사용 시 불편한 수작업을 자동화 특정 프로젝트 폴더로 들어가면 .env 파일을 실행하여 가상환경 활성화 맥, OS X 사전 준비사항12sudo xcode-select --installbrew install homebrew/dupes/zlib pyenv 설치1234brew install pyenv# pyenv 업그레이드brew upgrade pyenv 환경변수 적용 및 업데이트다음 명령을 터미널에서 수행하여 환경변수를 등록한다. zsh를 사용할 때는 &quot;~/.bash_profile&quot;을 &quot;~/.zshrc&quot;로 변경하여 실행한다. 1234echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.bash_profileecho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.bash_profileecho 'eval \"$(pyenv init -)\"' &gt;&gt; ~/.bash_profilesource ~/.bash_profile pyenv를 이용한 python 설치12345678910pyenv install 3.6.5pyenv versions* system (set by /Users/p829911/.pyenv/version) 3.6.5 3.6.5/envs/tensorflow 3.7.2 3.7.2/envs/speech speech tensorflow 여기서 설치가 되지 않고 오류가 나는 경우 다음 명령으로 실행시켜 준다. 123CFLAGS=\"-I$(brew --prefix openssl)/include -I$(xcrun --show-sdk-path)/usr/include\" \\LDFLAGS=\"-L$(brew --prefix openssl)/lib\" \\pyenv install -v 3.6.5 pyenv-virtualenv 사용하기1234567891011121314151617# pyenv-virtualenv 설치brew install pyenv-virtualenv# 환경변수 설정echo 'eval \"$(pyenv virtualenv-init -)\"' &gt;&gt; ~/.bashrc# virtualenv 생성pyenv virtualenv &lt;virtualenv-name&gt;# virtualenv 활성화pyenv activate &lt;virtualenv-name&gt;# virtualenv 비활성화pyenv deactivate# virtualenv 삭제pyenv uninstall &lt;version&gt; / &lt;virtualenv-name&gt; autoenv123456# 설치brew install autoenv# 환경설정echo \"source $(brew --prefix autoenv)/activate.sh\" &gt;&gt; ~/.bashrcsource ~/.bashrc 가상 환경을 활성화 할 폴더에 .env 파일을 만들어 준다. 123vi &lt;virtualenv-folder&gt;/.envpyenv activate &lt;virtualenv-name&gt; 폴더를 나오면 다시 deactivate를 적용시켜 준다. 12345vi ~/.envpyenv deactivate# orpyenv shell system pip를 이용해 라이브러리 설치가상환경은 pip를 이용해 설치하는 패키지 또한 분리하여 관리해주기 때문에 원래 설치해 두었던 라이브러리들을 다시 깔아 줄 필요가 있다. 1pip3 freeze &gt; requirements.txt 위 명령어는 현재 pip3로 python3 환경에서 깔려있는 라이브러리이름과 버전을 requirement.txt 파일에 저장해 주는 명령어이다. 1234567891011121314jupyter==1.0.0jupyter-client==5.1.0jupyter-console==5.2.0jupyter-core==4.3.0MarkupSafe==1.0mistune==0.7.4nbconvert==5.3.1nbformat==4.4.0notebook==5.0.0pandocfilters==1.4.2pexpect==4.2.1pickleshare==0.7.4prompt-toolkit==1.0.15... requirements.txt 파일에 적힌 모든 라이브러리를 설치하는 pip 명령은 다음과 같다. 가상환경폴더로 이동 한 후 1pip install -r requirements.txt","categories":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/tags/Python/"}]},{"title":"모의고사","slug":"모의고사","date":"2019-01-14T07:20:05.000Z","updated":"2019-01-14T07:22:27.797Z","comments":true,"path":"2019/01/14/모의고사/","link":"","permalink":"https://p829911.github.io/2019/01/14/모의고사/","excerpt":"","text":"문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어 있습니다. 문제의 정답은 1, 2, 3, 4, 5 중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return 하는 값을 오름차순 정렬해주세요 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 입출력 예 설명입출력 예 # 1 수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. 입출력 예 # 2 수포자 1은 [1,4]번 문제를 맞혔습니다. 수포자 2는 다섯 번째 문제를 맞혔습니다. 나의 풀이123456789101112131415161718192021222324252627282930def solution(answer): dic = &#123;1: 0, 2: 0, 3: 0&#125; math1 = [1,2,3,4,5] * 8 math2 = [2,1,2,3,2,4,2,5] * 5 math3 = [3,3,1,1,2,2,4,4,5,5] * 4 mul = 2 while len(math1) &lt; len(answer): math1 = math1 * mul math2 = math2 * mul math3 = math3 * mul mul += 1 for i in range(len(answer)): if math1[i] == answer[i]: dic[1] += 1 if math2[i] == answer[i]: dic[2] += 1 if math3[i] == answer[i]: dic[3] += 1 max_num = max(dic.values()) ls = [] for i in range(1, 4): if dic.get(i) &gt; (max_num-1): ls.append(i) return sorted(ls) 다른 사람의 풀이1234567891011121314151617181920def solution(answers): pattern1 = [1,2,3,4,5] pattern2 = [2,1,2,3,2,4,2,5] pattern3 = [3,3,1,1,2,2,4,4,5,5] score = [0,0,0] result = [] for idx, answer in enumerate(answers): if answer == pattern1[idx%len(pattern1)]: score[0] += 1 if answer == pattern2[idx%len(pattern2)]: score[1] += 1 if answer == pattern3[idx%len(pattern3)]: score[2] += 1 for idx, s in enumerate(score): if s == max(score): result.append(idx+1) return result 한계점 %를 이용한 몫 계산을 생각하지 못했다. 1 % 5 = 1, 5 % 5 = 0, 6 % 5 = 1 마지막 결과가 ascending 이면 되기 때문에 range와 for을 이용해 앞 index 부터 접근하는 경우 sorted 함수를 안써도 됐다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/tags/Algorithm/"}]},{"title":"완주하지 못한 선수","slug":"완주하지-못한-선수","date":"2019-01-12T06:02:05.000Z","updated":"2019-01-14T07:19:53.297Z","comments":true,"path":"2019/01/12/완주하지-못한-선수/","link":"","permalink":"https://p829911.github.io/2019/01/12/완주하지-못한-선수/","excerpt":"","text":"문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [“leo”, “kiki”, “eden”] [“eden”, “kiki”] “leo” [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] [“josipa”, “filipa”, “marina”, “nikola”] “vinko” [“mislav”, “stanko”, “mislav”, “ana”] [“stanko”, “ana”, “mislav”] “mislav” 입출력 예 설명예제 #1 leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2 vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3 mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 프로그래머스 첫번째 시도1234def solution(participant, completion): for c in completion: participant.remove(c) return participant[0] 정확성: 50 효율성: 0두번째 시도123456789101112def solution(participant, completion): dic = &#123;&#125; for p in participant: try: dic[p] += 1 except: dic[p] = 1 for c in completion: if c in dic: dic[c] -= 1 if dic[c] == 0: del dic[c] return list(dic.keys())[0] 통과다른 사람들의 풀이112345from collections import Counterdef solution(participant , completion): answer = Counter(participant) - Counter(completion) return list(answer.keys())[0] 21234567def solution(participant, completion): participant.sort() completion.sort() for p,c in zip(participant, completion): if p != c: return p return participant[-1] Collections module function description namedtuple() factory function for creating tuple subclasses with named fields deque list-like container with fast appends and pops on either end Counter dict subclass for counting hashable objects OrderedDict dict subclass that remembers the order entries were added defaultdict dict subclass that calls a factory function to supply missing values Counter1234567# 목록의 단어 집계cnt = Counter()for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']: cnt[word] += 1cnt# Counter(&#123;'red': 2, 'blue': 3, 'green': 1&#125;) 123456# Counter objects는 사전과 사용 인터페이스는 같지만 missing item에 대해서 # key error를 발생시키지 않고, 0을 반환한다.c = Counter(['eggs', 'ham'])c['bacon']# 0 12345c = Counter(a=4, b=2, c=0, d=-2)c.update(['a','b','c','d'])c# Counter(&#123;'a': 5, 'b': 3, 'c': 1, 'd': -1&#125;) 123Counter('abracadabra').most_common(3)# [('a', 5), ('b', 2), ('r', 2)]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://p829911.github.io/tags/Algorithm/"}]},{"title":"crontab","slug":"crontab","date":"2019-01-11T02:53:56.000Z","updated":"2019-01-12T06:21:52.617Z","comments":true,"path":"2019/01/11/crontab/","link":"","permalink":"https://p829911.github.io/2019/01/11/crontab/","excerpt":"","text":"리눅스 크론탭 사용법 “특정 시간에 특정 작업을 해야한다.” 1. 크론탭 기본 (crontab basic)12345678910111213# 크론탭 실행crontab -e# 현재 크론탭에 어떤 내용이 들어있는지 보기crontab -l# 크론탭을 지우고 싶을 때crontab -r# 저장은 vi 처럼 콜론(:) 입력 후 wq로 갱신***** ls -al# 별이 다섯개 있는 경우에 \"매분마다 실행\" 2. 주기 결정12* * * * *분(0-59) 시간(0-23) 일(1-31) 월(1-12) 요일(0-7) 각 별 위치에 따라 주기를 다르게 설정 할 수 있다. 순서대로 분-시간-일-월-요일 순이다. 그리고 괄호 안의 숫자 범위 내로 별 대신 입력할 수 있다. 요일에서 0과 7은 일요일이다. 1부터 월요일이고, 6이 토요일이다. 3. 주기별 예제1234567891011121314151617# 매분 test.sh 실행* * * * * /home/script/test.sh# 매주 금요일 오전 5시 45분에 test.sh 를 실행45 5 * * 5 /home/script/test.sh# 매일 매시간 0분, 20분, 40분에 test.sh 를 실행0,20,40 * * * * /home/script/test.sh# 매일 1시 0분부터 30분까지 매분 test.sh 를 실행0-30 1 * * * /home/script/test.sh# 매 10분마다 test.sh 를 실행*/10 * * * * /home/script/test.sh# 5일에서 6일까지 2시, 3시, 4시에 매 10분마다 test.sh를 실행*/10 2,3,4 5-6 * * /home/script/test.sh 주기 입력 방법엔 *, - , / 을 이용하는 방법이 있다. 위에서 봤듯이 각각의 특수기호가 하는 기능이 다르고 조합을 어떻게 하느냐에 따라 주기를 설정 할 수 있다. 크론 사용 팁1234567# 한 줄에 하나의 명령만 쓴다. # 잘못된 예* * * 5 5/home/script/test.sh# 잘된 예* * * 5 5 /home/script.test.sh 크론 로깅 (cron logging)해당 처리 내역에 대해 로그를 남기고 싶을 때 1* * * * * /home/script/test.sh &gt; /home/script/test.sh.log 2&gt;&amp;1 위에서 2&gt;&amp;1이란make를 하면 일반 출력은 stdout, 에러 메시지는 stderr로 출력 된다.stderr을 stdout으로 돌려서 에러 메세지도 저장되게 하라는 의미이다.n&gt;&amp;m: 표준 출력과 표준 에러를 서로 바꾸기 0: 표준 입력 1: 표준 출력 2: 표준 에러 너무 자주 실행 되고 지속적으로 로깅이 되야 해서 로그를 계속 남겨둬야 한다면 1* * * * * /home/script/test.sh &gt;&gt; /home/script/test.sh.log 2&gt;&amp;1 위의 코드를 실행하면 계속 로그가 누적이 되는 것을 확인 할 수 있다. 그러나 로그가 과도하게 쌓이면 리눅스 퍼포먼스에 영향을 주므로 가끔씩 비워주거나 파일을 새로 만들어주는 작업이 필요하다. 크론탭 백업 (crontab backup)혹시라도 crontab -r을 쓰거나 실수로 crontab 디렉토리를 날려버려서 기존 크론 내역들이 날아갔을 때를 대비하여 주기적으로 크론탭을 백업해 주어야 한다. 1crontab -l &gt; /home/bak/crantab_bak.txt 크론탭 내용을 txt파일로 만들어 저장해 두는 것이다. 12# 자동화50 23 * * * crontab -l &gt; /home/bak/crontab_bak.txt 매일 오후 11시 50분에 크론탭을 백업해 두는 명령어이다.","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"},{"name":"Crontab","slug":"Crontab","permalink":"https://p829911.github.io/tags/Crontab/"}]},{"title":"그래프 이론 기초","slug":"그래프-이론-기초","date":"2019-01-11T02:51:47.000Z","updated":"2019-01-11T02:53:22.398Z","comments":true,"path":"2019/01/11/그래프-이론-기초/","link":"","permalink":"https://p829911.github.io/2019/01/11/그래프-이론-기초/","excerpt":"","text":"그래프(graph)는 다음 그림처럼 노드(node, vertex)와 그 사이를 잇는 간선(edge)으로 이루어진 구조를 말한다. 123456789import networkx as nxfrom IPython.core.display import Imagefrom networkx.drawing.nx_pydot import to_pydotg = nx.complete_graph(4)d = to_pydot(g)d.set_dpi(600)d.set_rankdir(\"LR\")Image(d.create_png(), width=600) 수학적으로 그래프 $G$ 는 노드(vertex) 집합 $V$ 와 간선(edge) 집합 $E$ 로 구성된다. G = (V, E)간선은 두 개의 노드로 이루어진 순서가 있는 쌍(ordered pair)이다. E \\subseteq V \\times V위에서 그린 그래프는 4개의 노드 집합 V = \\{0, 1, 2, 3 \\}과 6개의 간선 집합 E = \\{ (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3) \\}을 가진다. 방향성 그래프와 비방향성 그래프만약 간선 (a, b)와 (b, a)이 있을 때 이 두 간선을 다른 것으로 본다면 간선의 방향이 있는 방향성 그래프(directed graph)이고 두 간선을 같은 것으로 본다면 간선의 방향이 없는 비방향성 그래프(undirected graph)이다. 그래프를 시각화를 할 때 방향성은 화살표로 표시한다. NetworkX 패키지NetworkX는 그래프를 다루기 위한 파이썬 패키지이다. 그래프를 만드는 클래스 Graph, DiGraph 를 제공한다. Graph 클래스는 비방향성 그래프, DiGraph 클래스는 방향성 그래프를 나타낸다. NetworkX 패키지는 원래 버전 2 이상이 나와 있지만 나중에 사용할 pgmpy 패키지와의 호환성을 위해 버전 1.11을 사용하도록 한다. 1234import networkxnetworkx.__version__'1.11' 12import networkx as nxg1 = nx.DiGraph() 노드를 추가할 때는 add_node 메서드를 사용한다. 노드의 이름으로는 숫자나 문자열을 사용할 수 있다. 그래프에 포함된 노드는 nodes 메서드(버전 2에서는 속성)으로 확인할 수 있다. 123456g1.add_node(\"a\")g1.add_node(1)g1.add_node(2)g1.nodes()['a', 1, 2] 간선을 추가할 때는 add_edge 메서드를 사용한다. 간선을 이을 두 노드를 인수로 입력한다. 그래프에 포함된 노드는 edges 속성으로 확인할 수 있다. 12345g1.add_edge(1, \"a\")g1.add_edge(1, 2)g1.edges()[(1, 'a'), (1, 2)] 만약 graphviz 프로그램과 pydot 패키지가 설치되어 있다면 이를 이용하여 시각화 할 수도 있다. 12345678from IPython.core.display import Imagefrom networkx.drawing.nx_pydot import to_pydotd1 = to_pydot(g1)d1.set_dpi(300)d1.set_rankdir(\"LR\")d1.set_margin(1)Image(d1.create_png(), width=300) 노드 집합 $V$와 간선 집합 $V$ 를 가지는 그래프 $G$ 에 포함된 노드의 갯수를 그래프의 크기(cardinality)라고 하며 $|G|$ 또는 $|V|$ 로 나타내고 간선의 갯수는 $|E|$ 로 나타낸다. NetworkX 패키지에서는 각각 len 명령, number_of_nodes, number_of_edges 메서드로 계산할 수 있다. 123len(g1), g1.number_of_nodes(), g1.number_of_edges()(3, 3, 2) 만약 두 노드$a$,$b$ 를 포함하는 간선 $(a, b)$가 $E$ 안에 존재하면 두 노드는 인접하다(adjacent)고 하며 인접한 두 노드는 서로 이웃(neighbor)이라고 한다. (a, b) \\in ENetworkX 패키지 Graph 클래스의 neighbors 메서드는 인수로 받은 노드에 인접한 노드를 생성하므로 인접성을 확인하는데 사용할 수 있다. 12345for n in g1.neighbors(1): print(n) a2 1232 in g1.neighbors(1), 1 in g1.neighbors(2), \"a\" in g1.neighbors(2), \"a\" in g1.neighbors(1)(True, False, False, True) 만약 어떤 노드에서 출발하여 자기 자신으로 바로 돌아오는 간선이 있다면 셀프 루프(self loop)라고 한다. 다음 그래프에서는 노드 2에 셀프 루프가 있다. 12345678g2 = nx.Graph()g2.add_node(1)g2.add_node(2)g2.add_node(3)g2.add_edge(1, 2)g2.add_edge(2, 2)g2.add_edge(2, 3)np.random.seed(0) 셀프 루프가 있는 경우에는 graphviz로만 시각화 할 수 있다. 1234d2 = to_pydot(g2)d2.set_dpi(600)d2.set_rankdir(\"LR\")Image(d2.create_png(), width=600) 워크, 트레일, 패스어떤 노드를 출발해서 다른 노드로 도달하기 위한 인접한 노드의 순서열 워크(walk)라고 하고 워크 중에서 동일한 노드를 두 번 이상 지나지 않는 워크를 트레일(trail), 시작과 끝을 제외하고 다른 노드에 대해서만 동일한 노드를 두번이상 지나지 않는 패스(path)라고 한다. 패스 중에서 시작점과 끝점이 동일한 패스를 사이클(cycle)이라고 한다. 사이클이 없는 그래프를 어사이클릭 그래프(acyclic graph)라고 한다. 다음 그래프 g3에서 워크, 트레일, 패스, 사이클을 찾아보자 $a - c - d - c - e$는 $a$에서 $c$로 가는 워크이다. 하지만 트레일이나 패스는 아니다. $a - b - c - d- e$ 는 트레일이다. $a - b - c - d - e - c$ 는 패스지만 트레일은 아니다. $a - b - c - a$ 는 사이클이다. 123456789101112131415161718g3 = nx.DiGraph()g3.add_node(\"a\")g3.add_node(\"b\")g3.add_node(\"c\")g3.add_node(\"d\")g3.add_node(\"e\")g3.add_node(\"f\")g3.add_edge(\"a\", \"b\")g3.add_edge(\"a\", \"c\")g3.add_edge(\"b\", \"c\")g3.add_edge(\"c\", \"d\")g3.add_edge(\"d\", \"e\")g3.add_edge(\"c\", \"e\")d3 = to_pydot(g3)d3.set_dpi(600)d3.set_rankdir(\"LR\")Image(d3.create_png(), width=800) has_path 명령으로 두 노드간에 패스가 존재하는지 알 수 있다. 패스가 존재하면 shortest_path 명령으로 가장 짧은 패스를 구할 수 있다. 123nx.has_path(g3, \"a\", \"b\"), nx.has_path(g3, \"a\", \"e\"), nx.has_path(g3, \"a\", \"f\")(True, True, False) 123nx.shortest_path(g3, \"a\", \"e\")['a', 'c', 'e'] 클리크무방향성 그래프의 노드 집합 중에서 모든 노드끼리 간선이 존재하면 그 노드 집합을 클리크(clique)라고 한다. 만약 클리크에 포함된 노드에 인접한 다른 노드를 추가하면 클리크가 아니게 되는 것을 최대클리크(maximal clique)라고 한다. 다음 그래프 $g4$ 에서 클리크를 찾아보자 $\\{a, b\\}$ 는 클리크이다. 하지만 최대 클리크는 아니다. $\\{a, b, c\\}$ 는 클리크이며 최대 클리크이다. 1234567891011121314151617181920g4 = nx.Graph()g4.add_node(\"a\")g4.add_node(\"b\")g4.add_node(\"c\")g4.add_node(\"d\")g4.add_node(\"e\")g4.add_node(\"f\")g4.add_edge(\"a\", \"b\")g4.add_edge(\"a\", \"c\")g4.add_edge(\"b\", \"c\")g4.add_edge(\"b\", \"d\")g4.add_edge(\"c\", \"d\")g4.add_edge(\"d\", \"e\")g4.add_edge(\"d\", \"f\")g4.add_edge(\"e\", \"f\")d4 = to_pydot(g4)d4.set_dpi(600)d4.set_rankdir(\"LR\")Image(d4.create_png(), width=800) cliques_containing_node 명령은 특정 노드를 포함하는 클리크를 찾는다. 123nx.cliques_containing_node(g4, [\"a\"])&#123;'a': [['a', 'b', 'c']]&#125; 123nx.cliques_containing_node(g4, [\"a\", \"b\"])&#123;'a': [['a', 'b', 'c']], 'b': [['d', 'b', 'c'], ['a', 'b', 'c']]&#125; enumerate_all_cliques 명령은 모든 클리크를, find_cliques 는 모든 최대 클리크를 찾는다. 12345678910111213141516171819[c for c in nx.enumerate_all_cliques(g4)][['a'], ['b'], ['c'], ['d'], ['e'], ['f'], ['a', 'b'], ['a', 'c'], ['b', 'c'], ['b', 'd'], ['c', 'd'], ['d', 'e'], ['d', 'f'], ['e', 'f'], ['a', 'b', 'c'], ['b', 'c', 'd'], ['d', 'e', 'f']] 123[c for c in nx.find_cliques(g4)][['d', 'b', 'c'], ['d', 'e', 'f'], ['a', 'b', 'c']]","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Network","slug":"Math/Network","permalink":"https://p829911.github.io/categories/Math/Network/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Unsupervised Learning","slug":"Unsupervised-Learning","permalink":"https://p829911.github.io/tags/Unsupervised-Learning/"},{"name":"Network","slug":"Network","permalink":"https://p829911.github.io/tags/Network/"}]},{"title":"Affinity Propagation","slug":"Affinity-Propagation","date":"2019-01-11T01:17:57.000Z","updated":"2019-01-11T01:20:49.385Z","comments":true,"path":"2019/01/11/Affinity-Propagation/","link":"","permalink":"https://p829911.github.io/2019/01/11/Affinity-Propagation/","excerpt":"","text":"모든 데이터가 특정한 기준에 따라 자신을 대표할 대표 데이터를 선택한다. 만약 스스로가 자기 자신을 대표하게 되면 클러스터의 중심이 된다. responsibility $r(i,k)$ $k$ 번째 데이터가 $i$ 번째 데이터의 대표가 되어야 한다는 증거 availability $a(i, k)$ $i$ 번째 데이터가 $k$ 번째 데이터를 대표로 선택해야 한다는 증거 다음 수식을 수렴할 때까지 반복 r(i, k) \\leftarrow s(i,k) - \\text{max}_{k' \\neq k}(a(i,k') + s(i, k'))\\\\ a(i,k) \\leftarrow \\text{min}(0, r(k,k) + \\sum_{i' \\neq i,k}r(i',k)) \\\\여기에서 $s(i,k)$ 는 다음과 같이 음의 거리로 정의되는 유사도이다. s(i, k) = -||x_i - x_k||^2특히 $s(k,k)$ 는 특정한 음수 값으로 사용자가 정해 주게 되는데 이 값에 따라서 클러스터의 갯수가 달라지는 하이퍼 모수가 된다. $s(k,k)$ 가 크면 자기 자신에 대한 유사도가 커져서 클러스터의 수가 증가한다. 위 알고리즘으로 계산하는 $r, a$ 가 더 이상 변화하지 않고 수렴하면 계산이 종료되고 종료 시점에서 $r(k, k) + a(k, k) &gt; 0$ 이 데이터가 클러스터의 중심이 된다. 12345678910111213141516171819202122from sklearn.datasets.samples_generator import make_blobsfrom sklearn.cluster import AffinityPropagationfrom sklearn.metrics import *centers = [[1, 1], [-1, -1], [1, -1]]X, labels_true = make_blobs(n_samples=300, centers=centers, cluster_std=0.5, random_state=0)model = AffinityPropagation(preference=-50).fit(X)cluster_centers_indices = model.cluster_centers_indices_labels = model.labels_n_clusters_ = len(cluster_centers_indices)print('Estimated number of clusters: %d' % n_clusters_)print(\"Adjusted Rand Index: %0.3f\" % adjusted_rand_score(labels_true, labels))print(\"Adjusted Mutual Information: %0.3f\" % adjusted_mutual_info_score(labels_true, labels))print(\"Silhouette Coefficient: %0.3f\" % silhouette_score(X, labels, metric='sqeuclidean'))Estimated number of clusters: 3Adjusted Rand Index: 0.912Adjusted Mutual Information: 0.871Silhouette Coefficient: 0.753 123456789101112from itertools import cyclecolors = cycle('rgb')for k, col in zip(range(n_clusters_), colors): class_members = labels == k cluster_center = X[cluster_centers_indices[k]] plt.plot(X[class_members, 0], X[class_members, 1], col + '.') for x in X[class_members]: plt.plot([cluster_center[0], x[0]], [cluster_center[1], x[1]], col, alpha=0.25) plt.plot(cluster_center[0], cluster_center[1], 'o', mec='k', mew=3, markersize=7)plt.show()","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Clustering","slug":"Math/Clustering","permalink":"https://p829911.github.io/categories/Math/Clustering/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Clustering","slug":"Clustering","permalink":"https://p829911.github.io/tags/Clustering/"},{"name":"Affinity Propagation","slug":"Affinity-Propagation","permalink":"https://p829911.github.io/tags/Affinity-Propagation/"}]},{"title":"계층적 클러스터링","slug":"계층적-클러스터링","date":"2019-01-11T01:17:40.000Z","updated":"2019-01-11T01:21:50.993Z","comments":true,"path":"2019/01/11/계층적-클러스터링/","link":"","permalink":"https://p829911.github.io/2019/01/11/계층적-클러스터링/","excerpt":"","text":"계층적 클러스터링은 하나의 데이터 샘플을 하나의 클러스터로 보고 가장 유사도가 높은 클러스터를 합치면서 클러스터 갯수를 줄여 가는 방법을 말한다. 클러스터간의 거리 측정클러스터간의 비유사도(dissimilarity) 혹은 거리(distance)를 측정하는 방법에는 다음과 같은 것이 있다. 비귀납적 방법centroid 두 클러스터의 중심점(centroid)를 정의한 다음 두 중심점의 거리를 클러스터간의 거리로 정의한다. d(u, v) = || c_u - c_v ||^2여기에서 $c_u$ 와 $c_v$ 각각 두 클러스터 $u$ 와 $v$ 의 중심점이다. single 클러스터 $u$ 의 모든 데이터 $i$ 와 클러스터 $v$ 의 모든 데이터 $j$ 의 모든 조합에 대해 거리를 측정해서 최소값을 구한다. 최소 거리(Nearest Point) 방법이라고도 한다. d(u,v) = \\text{min}(\\text{dist}(u[i], v[j]))complete 클러스터 $u$ 의 모든 데이터 $i$ 와 클러스터 $v$ 의 모든 데이터 $j$ 의 모든 조합에 대해 거리를 측정한 후 가장 큰 값을 구한다. Farthest Point Algorithm 또는 Voor Hees Algorithm 이라고 한다. d(u,v) = \\text{max}(\\text{dist}(u[i], v[j]))average 클러스터 $u$ 의 모든 데이터 $i$ 와 클러스터 $v$ 의 모든 데이터 $j$ 의 모든 조합에 대해 거리를 측정한 후 평균을 구한다. $|u|$ 와 $|v|$ 는 각각 두 클러스터의 원소의 갯수를 뜻한다. d(u,v) = \\sum_{ij} \\dfrac{d(u[i], v[j])}{|u||v|}귀납적 방법median 이 방법은 Agglomerative Clustering에서 사용할 수 있는 귀납적 방법으로 centroid 방법의 변형이다. 만약 클러스터 $u$가 클러스터 $s$ 와 클러스터 $t$ 가 결합하여 생겼다면 클러스터 $u$ 의 중심점은 새로 계산하지 않고 원래 클러스터의 두 클러스터의 중심점의 평균을 사용한다. weighted 이 방법은 Agglomeratice Clustering 에서 사용할 수 있는 귀납적 방법이다. 만약 클러스터 $u$ 가 클러스터 $s$ 와 클러스터 $t$ 가 결합하여 생겼다면 다음과 같이 원래 클러스터까지의 두 거리의 평균을 사용한다. d(u,v) = (dist(s,v) + dist(t,v))/2Ward 이 방법은 Agglomerative Clustering 에서 사용할 수 있는 귀납적 방법이다. 만약 클러스터 $u$ 가 클러스터 $s$ 와 클러스터 $t$ 가 결합하여 생겼다면 다음과 같이 두 클러스터 거리의 가중 평균에서 원래의 두 클러스터 사이의 거리를 보정한 값을 사용한다. d(u,v) = \\sqrt{\\frac{|v|+|s|}{|v|+|s|+|t|}d(v,s)^2 + \\frac{|v|+|t|}{|v|+|s|+|t|}d(v,t)^2 - \\frac{|v|}{|v|+|s|+|t|}d(s,t)^2}이 식에서 $|\\cdot|$ 기호는 클러스터의 원소의 갯수를 말한다. SciPy의 계층적 클러스터링파이썬으로 계층적 클러스터링을 하려면 SciPy 패키지의 linkage 명령을 사용하거나 scikit-learn 패키지의 AgglomerativeClustering 클래스를 사용한다. 각각 장단점이 있는데 SciPy 패키지는 tree 형태로 시각화해주는 dendrogram 명령도 지원한다. MNIST digit 이미지 중 20개의 이미지를 무작위로 골라 계층적 클러스터링을 적용해보자. 1234567891011121314151617from sklearn.datasets import load_digitsdigits = load_digits()n_image = 20np.random.seed(0)idx = np.random.choice(range(len(digits.images)), n_image)X = digits.data[idx]images = digits.images[idx]plt.figure(figsize=(12, 1))for i in range(n_image): plt.subplot(1, n_image, i + 1) plt.imshow(images[i], cmap=plt.cm.bone) plt.grid(False) plt.xticks(()) plt.yticks(()) plt.title(i) 1234from scipy.cluster.hierarchy import linkage, dendrogramZ = linkage(X, 'ward')Z 1234567891011121314151617181920212223from matplotlib.offsetbox import OffsetImage, AnnotationBboxplt.figure(figsize=(10, 4))ax = plt.subplot()ddata = dendrogram(Z)dcoord = np.array(ddata[\"dcoord\"])icoord = np.array(ddata[\"icoord\"])leaves = np.array(ddata[\"leaves\"])idx = np.argsort(dcoord[:, 2])dcoord = dcoord[idx, :]icoord = icoord[idx, :]idx = np.argsort(Z[:, :2].ravel())label_pos = icoord[:, 1:3].ravel()[idx][:20]for i in range(20): imagebox = OffsetImage(images[i], cmap=plt.cm.bone_r, interpolation=\"bilinear\", zoom=3) ab = AnnotationBbox(imagebox, (label_pos[i], 0), box_alignment=(0.5, -0.1), bboxprops=&#123;\"edgecolor\" : \"none\"&#125;) ax.add_artist(ab)plt.show()","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Clustering","slug":"Math/Clustering","permalink":"https://p829911.github.io/categories/Math/Clustering/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Clustering","slug":"Clustering","permalink":"https://p829911.github.io/tags/Clustering/"},{"name":"계층적 클러스터링","slug":"계층적-클러스터링","permalink":"https://p829911.github.io/tags/계층적-클러스터링/"}]},{"title":"DBSCAN","slug":"DBSCAN","date":"2019-01-11T01:17:05.000Z","updated":"2019-01-11T01:19:19.308Z","comments":true,"path":"2019/01/11/DBSCAN/","link":"","permalink":"https://p829911.github.io/2019/01/11/DBSCAN/","excerpt":"","text":"K-Means 클러스터링 방법은 단순하고 강력한 방법이지만 클러스터의 모양이 원형이 아닌 경우에는 잘 동작하지 않으며 클러스터의 갯수를 사용자가 지정해주어야 한다는 단점이 있다. DBSCAN(Density-Based Spatial Clustering of Applications with Noise) 방법은 데이터가 밀집한 정도 즉 밀도를 이용하여 클러스터의 형태에 구애받지 않으며 클러스터의 갯수를 사용자가 지정할 필요가 없다. DBSCAN 방법에서는 초기 데이터로부터 근접한 데이터를 찾아나가는 방법으로 클러스터를 확장한다. 이 때 다음 사용자 인수를 사용한다. epsilon $\\epsilon$: 이웃(neighborhood)을 정의하기 위한 거리 최소 데이터 갯수(minimum points): 밀집 지역을 정의하기 위해 필요한 이웃의 갯수 만약 $\\epsilon$ 거리 안의 이웃 영역안에 최소 데이터 갯수 이상의 데이터가 있으면 그 데이터는 핵심(core) 데이터이다. 이렇게 핵심 데이터를 찾아낸 다음에는 이 핵심 데이터의 이웃영역 안에 있는 데이터를 이 핵심데이터와 연결된(reached) 고밀도 데이터로 정의한다. 고밀도 데이터의 이웃영역 안에 있는 데이터도 마찬가지로 연결된 고밀도 데이터가 된다. 만약 고밀도 데이터에 더이상 이웃이 없으면 이 데이터는 경계(border) 데이터라고 하며 연결은 끝난다. 핵심 데이터도 아니고 경계 데이터도 아닌 데이터를 outlier라고 한다. scikit-learn의 cluster 서브패키지는 DBSCAN 클러스터링을 위한 DBSCAN 클래스를 제공한다. 다음과 같은 인수를 받을 수 있다. eps: 이웃을 정의하기 위한 거리. epsilon. min_samples: 핵심 데이터를 정의하기 위해 필요한 이웃영역안의 데이터 갯수. 클러스터링이 끝나면 다음 속성을 가진다. labels_: 클러스터 번호 core_sample_indices_: 핵심 데이터의 인덱스 다음은 make_circles 명령과 make_moons 명령으로 만든 동심원, 초승달 데이터를 DBSCAN 방법으로 클러스터링한 결과를 나타낸 것이다. 마커(marker)의 모양은 클러스터를 나타내고 마커의 크기가 큰 데이터는 핵심데이터, x 표시된 데이터는 outlier이다. 1234567891011121314151617181920212223242526272829303132333435from sklearn.datasets import make_circles, make_moonsfrom sklearn.cluster import DBSCANn_samples = 1000np.random.seed(2)X1, y1 = make_circles(n_samples=n_samples, factor=.5, noise=.09)X2, y2 = make_moons(n_samples=n_samples, noise=.1)def plot_DBSCAN(title, X, eps, xlim, ylim): model = DBSCAN(eps=eps) y_pred = model.fit_predict(X) idx_outlier = np.logical_not((model.labels_ == 0) | (model.labels_ == 1)) plt.scatter(X[idx_outlier, 0], X[idx_outlier, 1], marker='x', lw=1, s=20) plt.scatter(X[model.labels_ == 0, 0], X[model.labels_ == 0, 1], marker='o', facecolor='g', s=5) plt.scatter(X[model.labels_ == 1, 0], X[model.labels_ == 1, 1], marker='s', facecolor='y', s=5) X_core = X[model.core_sample_indices_, :] idx_core_0 = np.array(list(set(np.where(model.labels_ == 0)[0]).intersection(model.core_sample_indices_))) idx_core_1 = np.array(list(set(np.where(model.labels_ == 1)[0]).intersection(model.core_sample_indices_))) plt.scatter(X[idx_core_0, 0], X[idx_core_0, 1], marker='o', facecolor='g', s=80, alpha=0.3) plt.scatter(X[idx_core_1, 0], X[idx_core_1, 1], marker='s', facecolor='y', s=80, alpha=0.3) plt.grid(False) plt.xlim(*xlim) plt.ylim(*ylim) plt.xticks(()) plt.yticks(()) plt.title(title) return y_predplt.figure(figsize=(10, 5))plt.subplot(121)y_pred1 = plot_DBSCAN(\"동심원 클러스터\", X1, 0.1, (-1.2, 1.2), (-1.2, 1.2))plt.subplot(122)y_pred2 = plot_DBSCAN(\"초승달 클러스터\", X2, 0.1, (-1.5, 2.5), (-0.8, 1.2))plt.tight_layout()plt.show() 이 클러스터링 결과의 adjusted Rand index와 adjusted mutual info 값은 다음과 같다. 1234567891011from sklearn.metrics.cluster import adjusted_mutual_info_score, adjusted_rand_scoreprint(\"Circle ARI:\", adjusted_rand_score(y1, y_pred1))print(\"Circle AMI:\", adjusted_mutual_info_score(y1, y_pred1))print(\"Moon ARI:\", adjusted_rand_score(y2, y_pred2))print(\"Moon AMI:\", adjusted_mutual_info_score(y2, y_pred2))Circle ARI: 0.9414262371038592Circle AMI: 0.8361564005781013Moon ARI: 0.9544844153926417Moon AMI: 0.8606657095694518","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Clustering","slug":"Math/Clustering","permalink":"https://p829911.github.io/categories/Math/Clustering/"}],"tags":[{"name":"Clustering","slug":"Clustering","permalink":"https://p829911.github.io/tags/Clustering/"},{"name":"MATH","slug":"MATH","permalink":"https://p829911.github.io/tags/MATH/"},{"name":"DBSCAN","slug":"DBSCAN","permalink":"https://p829911.github.io/tags/DBSCAN/"}]},{"title":"terraform","slug":"terraform","date":"2019-01-11T01:09:47.000Z","updated":"2019-01-11T01:12:57.873Z","comments":true,"path":"2019/01/11/terraform/","link":"","permalink":"https://p829911.github.io/2019/01/11/terraform/","excerpt":"","text":"테라폼 기초 튜토리얼 terraform 테라폼은 하시코프에서 오픈소스로 개발중인 인프라스트럭처 관리 도구이다. 서비스 실행에 필요한 환경을 구축하는 도구라는 점에서 셰프나 앤서블 같은 설정 관리 도구와 더불어 프로비저닝 도구로 분류된다. 테라폼은 코드로서의 인프라스트럭처를 지향하고 있는 도구로서, GUI나 웹 콘솔을 사용해 서비스 실행에 필요한 리소스를 관리하는 대신 필요한 리소스들을 선언적인 코드로 작성해 관리할 수 있도록 해준다. 테라폼을 이용한 웹 애플리케이션 인프라스트럭처 프로비저닝 간단한 웹 어플리케이션을 아마존 웹 서비스에 배포하는 상황을 가정하겠다. 이 애플리케이션은 EC2가상 머신과 RDS 데이터베이스를 사용한다. 테라폼으로 이 인프라스트럭처를 구축하려면 다음과 같은 단계를 거친다. 1단계 - 먼저 아마존 웹 서비스 계정을 준비하고, API 키를 설정한다. 2단계 스텝1 - 인프라스트럭처를 묘사하기 위해 사용하는 HCL언어로 필요한 리소스를 선언한다. 2단계 스텝2 - 선언된 리소스들이 생성가능한지 계획(Plan)을 확인한다. 2단계 스텝3 - 선언된 리소스들을 아마존 웹 서비스에 적용(Apply)한다. 3단계 - 웹 애플리케이션을 배포한다. 테라폼의 기본 개념들프로비저닝 (Provisioning) 어떤 프로세스나 서비스를 실행하기 위한 준비 단계를 프로비저닝이라고 이야기한다. 프로비저닝에는 크게 네트워크나 컴퓨팅 자원을 준비하는 작업과 준비된 컴퓨팅 자원에 사이트 패키지나 애플리케이션에 의존성을 준비하는 단계로 나뉘어진다. 명확한 경계는 불분명하지만 테라폼은 전자에 치우쳐있는 도구라고 할 수 있다. 프로바이더 (Provider) 테라폼과 외부 서비스를 연결해주는 기능을 하는 모듈이다. 예를 들면 테라폼으로 AWS 서비스의 컴퓨팅 자원을 생성하기 위해서는 aws 프로바이더를 먼저 셋업해야한다. 프로바이더로는 AWS, 구글 클라우드 플랫폼, 마이크로소프트 애저와 같은 범용 클라우드 서비스를 비롯해 깃허브, 데이터도그, DNSimple과 같은 특정 기능을 제공하는 서비스, MySQL, 레빗MQ, 도커와 같은 로컬 서비스를 지원한다. 리소스 (자원 Resource) 리소스란 특정 프로바이더가 제공해주는 조작 가능한 대상의 최소 단위이다. 예를 들어 AWS 프로바이더는 aws_instance 리소스 타입을 제공하고, 이 리소스 타입을 사용해 Amazon EC2의 가상 머신 리소스를 선언하고 조작하는 것이 가능하다. EC2 인스턴스, 시큐리티 그룹, 키 페어 모두 aws 프로바이더가 제공해주는 리소스 타입이다. HCL (Hashicorp Configuration Language) HCL은 테라폼에서 사용하는 설정 언어이다. 테라폼에서 모든 설정과 리소스 선언은 HCL을 사용해 이루어진다. 테라폼에서 HCL파일의 확장자는 .tf를 사용한다. 계획 (Plan) 테라폼 프로젝트 디렉터리 아래의 모든 .tf 파일의 내용을 실제로 적용 가능한지 확인하는 작업을 계획이라고 한다. 테라폼은 이를 terraform plan 명령어로 제공하며, 이 명령어를 실행하면 어떤 리소스가 생성되고, 수정되고, 파괴될지 계획을 보여준다. 적용 (Apply) 테라폼 프로젝트 디렉터리 아래의 모든 .tf 파일의 내용대로 리소스를 생성, 수정, 파괴하는 일을 적용이라고 한다. 테라폼은 이를 terraform apply 명령어로 제공한다. 이 명령어를 실행하기 전에 변경 예정 사항은 plan 명령어를 사용해 확인할 수 있다.","categories":[{"name":"Server","slug":"Server","permalink":"https://p829911.github.io/categories/Server/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/tags/Python/"},{"name":"Teffaform","slug":"Teffaform","permalink":"https://p829911.github.io/tags/Teffaform/"},{"name":"AWS","slug":"AWS","permalink":"https://p829911.github.io/tags/AWS/"},{"name":"Server","slug":"Server","permalink":"https://p829911.github.io/tags/Server/"}]},{"title":"K-means","slug":"K-means","date":"2019-01-10T11:31:21.000Z","updated":"2019-01-10T11:34:35.975Z","comments":true,"path":"2019/01/10/K-means/","link":"","permalink":"https://p829911.github.io/2019/01/10/K-means/","excerpt":"","text":"K-MeansK-Means 클러스터링 알고리즘은 가장 단순하고 빠른 클러스터링 알고리즘의 하나이다. 다음과 같은 목적함수 값이 최소화될 때까지 클러스터의 중심(centroid)의 위치와 각 데이터가 소속될 클러스터를 반복해서 찾는다. 이 값을 inertia라고도 한다. J = \\sum_{k=1}^K\\sum_{i \\in C_k} d(x_i, u_k)이 식에서 $K$ 는 클러스터의 갯수이고 $C_k$ 는 $k$ 번째 클러스터에 속하는 데이터의 집합, $u_k$ 는 $k$ 번째 클러스터의 중심위치, $d$ 는 $x_i, u_k$ 두 데이터 사이의 거리(distance) 혹은 비유사도(dissimilarity)로 정의한다. 만약 유클리드 거리를 사용한다면 다음과 같다. d(x_i, u_k) = || x_i - u_k || ^ 2세부 알고리즘은 다음과 같다. 임의의 중심값 $u_k$ 를 고른다. 보통 데이터 샘플 중에서 $K$개를 선택한다. 중심에서 각 데이터까지의 거리를 계산 각 데이터에서 가장 가까운 중심을 선택하여 클러스터 갱신 다시 만들어진 클러스터에 대해 중심을 다시 계산하고 1~4를 반복한다. scikit-learn의 cluster 서브패키지는 Means 클러스터링을 위한 KMeans 클래스를 제공한다. 다음과 같은 인수를 받을 수 있다. n_clusters: 클러스터의 갯수 init: 초기화 방법. &quot;random&quot; 이면 무작위, &quot;K-means++&quot; 이면 K-means++ 방법. 또는 각 데이터의 클러스터 라벨 n_init: 초기 중심값 시도 횟수. 디폴트는 10이고 10개의 무작위 중심값 목록 중 가장 좋은 값을 선택한다. max_iter: 최대 반복 횟수. random_state: 시드값. 다음은 make_blobs 명령으로 만든 데이터를 2개로 K-means 클러스터링하는 과정을 나타낸 것이다. 마커(marker)의 모양은 클러스터를 나타내고 크기가 큰 마커가 중심값 위치이다. 각 단계에서 중심값은 전단계의 클러스터의 평균으로 다시 계산된다. 1234567891011121314151617181920212223242526from sklearn.datasets import make_blobsfrom sklearn.cluster import KMeansX, _ = make_blobs(n_samples=20, random_state=4)def plot_KMeans(n): model = KMeans(n_clusters=2, init=\"random\", n_init=1, max_iter=n, random_state=8).fit(X) c0, c1 = model.cluster_centers_ plt.scatter(X[model.labels_ == 0, 0], X[model.labels_ == 0, 1], marker='v', facecolor='r', edgecolors='k') plt.scatter(X[model.labels_ == 1, 0], X[model.labels_ == 1, 1], marker='^', facecolor='y', edgecolors='k') plt.scatter(c0[0], c0[1], marker='v', c=\"r\", s=200) plt.scatter(c1[0], c1[1], marker='^', c=\"y\", s=200) plt.grid(False) plt.title(\"iteration=&#123;&#125;, score=&#123;:5.2f&#125;\".format(n, model.score(X)))plt.figure(figsize=(8, 8))plt.subplot(321)plot_KMeans(1)plt.subplot(322)plot_KMeans(2)plt.subplot(323)plot_KMeans(3)plt.subplot(324)plot_KMeans(4)plt.tight_layout()plt.show() K-Means++K-Means++ 알고리즘은 초기 중심값을 설정하기 위한 알고리즘이다. 다음과 같은 방법을 통해 되도록 멀리 떨어진 중심값 집합을 나타낸다. 중심값을 저장할 집합 $M$ 준비 일단 하나의 중심 $\\mu_0$ 을 랜덤하게 선택하여 $M$ 에 넣는다. $M$ 에 속하지 않는 모든 샘플 $x_i$ 에 대해 거리 $d(M,x_i)$ 를 계산. $d(M, x_i)$ 는 $M$ 안의 모든 샘플 $\\mu_k$ 에 대해 $d(u_k, x_i)$ 를 계산하여 가장 작은 값 선택 $d(M, x_i)$ 에 비례한 확률로 다음 중심 $\\mu$ 를 선택. $K$ 개의 중심을 선택할 때까지 반복 K-Means 알고리즘 사용 다음은 KMean 방법을 사용하여 MNIST Digit 이미지 데이터를 클러스터링한 결과이다. 각 클러스터에서 10개씩의 데이터만 표시하였다. 1234567891011121314151617181920212223242526272829from sklearn.datasets import load_digitsdigits = load_digits()model = KMeans(init=\"k-means++\", n_clusters=10, random_state=0)model.fit(digits.data)y_pred = model.labels_def show_digits(images, labels): f = plt.figure(figsize=(8, 2)) i = 0 while (i &lt; 10 and i &lt; images.shape[0]): ax = f.add_subplot(1, 10, i + 1) ax.imshow(images[i], cmap=plt.cm.bone) ax.grid(False) ax.set_title(labels[i]) ax.xaxis.set_ticks([]) ax.yaxis.set_ticks([]) plt.tight_layout() i += 1 def show_cluster(images, y_pred, cluster_number): images = images[y_pred == cluster_number] y_pred = y_pred[y_pred == cluster_number] show_digits(images, y_pred) for i in range(10): show_cluster(digits.images, y_pred, i) 이미지의 제목에 있는 숫자는 클러스터 번호에 지나지 않으므로 원래 숫자의 번호와 일치하지 않는다. 하지만 이를 예측 문제라고 가정하고 분류 결과 행렬을 만들면 다음과 같다. 1234567891011121314from sklearn.metrics import confusion_matrixconfusion_matrix(digits.target, y_pred)array([[ 1, 0, 0, 0, 0, 177, 0, 0, 0, 0], [ 0, 1, 1, 0, 0, 0, 55, 99, 24, 2], [ 0, 13, 0, 2, 3, 1, 2, 8, 148, 0], [ 0, 154, 2, 13, 7, 0, 0, 7, 0, 0], [163, 0, 0, 0, 7, 0, 7, 4, 0, 0], [ 2, 0, 136, 43, 0, 0, 0, 0, 0, 1], [ 0, 0, 0, 0, 0, 1, 1, 2, 0, 177], [ 0, 0, 0, 0, 177, 0, 0, 2, 0, 0], [ 0, 2, 4, 53, 5, 0, 5, 100, 3, 2], [ 0, 6, 6, 139, 7, 0, 20, 2, 0, 0]]) 이 클러스터링 결과의 adjusted Rand index와 adjusted mutual info값은 다음과 같다. 123456789101112131415from sklearn.metrics.cluster import adjusted_mutual_info_score, adjusted_rand_scoreprint(adjusted_rand_score(digits.target, y_pred))print(adjusted_mutual_info_score(digits.target, y_pred))array([[ 1, 0, 0, 0, 0, 177, 0, 0, 0, 0], [ 0, 1, 1, 0, 0, 0, 55, 99, 24, 2], [ 0, 13, 0, 2, 3, 1, 2, 8, 148, 0], [ 0, 154, 2, 13, 7, 0, 0, 7, 0, 0], [163, 0, 0, 0, 7, 0, 7, 4, 0, 0], [ 2, 0, 136, 43, 0, 0, 0, 0, 0, 1], [ 0, 0, 0, 0, 0, 1, 1, 2, 0, 177], [ 0, 0, 0, 0, 177, 0, 0, 2, 0, 0], [ 0, 2, 4, 53, 5, 0, 5, 100, 3, 2], [ 0, 6, 6, 139, 7, 0, 20, 2, 0, 0]])","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Clustering","slug":"Math/Clustering","permalink":"https://p829911.github.io/categories/Math/Clustering/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Clustering","slug":"Clustering","permalink":"https://p829911.github.io/tags/Clustering/"}]},{"title":"clustering","slug":"clustering","date":"2019-01-05T11:30:02.000Z","updated":"2019-01-10T11:43:08.374Z","comments":true,"path":"2019/01/05/clustering/","link":"","permalink":"https://p829911.github.io/2019/01/05/clustering/","excerpt":"","text":"주어진 데이터 집합을 유사한 데이터들의 그룹으로 나누는 것을 클러스터링(clustering)이라고 하고 이렇게 나누어진 유사한 데이터의 그룹을 클러스터(cluster)라 한다. 클러스터링은 예측(prediction) 문제와 달리 특정한 독립변수와 종속변수의 구분도 없고 학습을 위한 목푯값(target value)도 필요로 하지 않는 비지도학습(unsupervised learning)의 일종이다. 클러스터링 방법대부분의 클러스터링 방법들도 예측모형처럼 특정한 목표함수의 값을 최소화 혹은 최대화하지만 예측모형과 달리 다만 목표함수가 명확히 주어지지 않았기 때문에 목표함수의 정의 및 최적화 방법들이 각기 다른 다양한 클러스터링 방법이 존재한다. 다음과 같은 클러스터링 방법이 많이 쓰인다. K-means DBSCAN Spectral Clustering Affinity Propagation 계층적 클러스터링(Hierarchical Clustering) 클러스터링 방법은 사용법과 모수 등이 서로 다르다. 예를 들어 K-means, Spectral Clustering 등은 클러스터의 갯수를 미리 지정해 주어야 하지만 DBSCAN이나 Affinity Propagation 등은 클러스터의 갯수를 지정할 필요가 없다. 다만 이 경우에는 다른 종류의 모수를 지정해주어야 하는데 이 모수의 값에 따라 클러스터링 갯수가 달라질 수 있다. 클러스터링 성능기준클러스터링 성능의 경우에는 분류문제와 달리 성능기준을 만들기 어렵다. 심지어는 원래 데이터가 어떻게 클러스터링되어 있었는지를 보여주는 정답(groundtruth)이 있는 경우도 마찬가지이다. 따라서 다양한 성능기준이 사용되고 있다. 다음은 클러스터링 성능기준의 예이다. Adjusted Rand Index Adjusted Mutual Information Silhouette Coefficient Incidence Matrix(adjusted) Rand index를 구하려면 데이터가 원래 어떻게 클러스터링되어 있어야 하는지를 알려주는 정답(groundtruth)이 있어야 한다. $N$개의 데이터 집합에서 $i, j$ 두 개의 데이터를 선택하였을 때 그 두 데이터가 같은 클러스터에 속하면 1 다른 데이터에 속하면 0이라고 하자. 이 값을 $N \\times N$ 행렬 $T$로 나타내자. T_{ij} = \\begin{cases} 1 &amp; \\text{$i$와 $j$가 같은 클러스터} \\\\ 0 &amp; \\text{$i$와 $j$가 다른 클러스터} \\end{cases}예를 들어 $\\{0, 1, 2, 3, 4\\}$라는 5개의 데이터 집합에서 $\\{0, 1, 2\\}$과 $\\{3, 4\\}$이 같은 클러스터라면 다음과 같아진다. 1234567groundtruth = np.array([ [1, 1, 1, 0, 0], [1, 1, 1, 0, 0], [1, 1, 1, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1],]) 이제 클러스터링을 적용한 결과를 같은 방법으로 행렬 $C$로 표시하자. 만약 클러스터링이 정확하다면 이 행렬은 정답을 이용해서 만든 행렬과 거의 같은 값을 가져야 한다 만약 클러스터링 결과 $\\{0,1\\}$ 과 $\\{2, 3, 4\\}$ 이 같은 클러스터라면 다음과 같아진다. 1234567clustering = np.array([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 1], [0, 0, 1, 1, 1], [0, 0, 1, 1, 1],]) 이 두 행렬의 모든 원소에 대해 값이 같으면 1 다르면 0으로 계산한 행렬을 incidence matrix라고 한다. 즉 데이터 집합에서 만들 수 있는 모든 데이터 쌍에 대해 정답과 클러스터링 결과에서 동일한 값을 나타내면 1, 다르면 0이 된다. R_{ij} = \\begin{cases} 1 &amp; \\text{if $T_{ij} = C_{ij}$} \\\\ 0 &amp; \\text{if $T_{ij} \\neq C_{ij}$} \\end{cases}즉, 원래 정답에서 1번 데이터와 2번 데이터가 다른 클러스터인데 클러스터링 결과에서도 다른 클러스터라고 하면 $R_{12} = 0$이다. 위 예제에서 incidence matrix를 구하면 다음과 같다. 1234567incidence = 1 * (groundtruth == clustering)incidencearray([[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 1, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]) Adjusted Rand IndexRand index는 가능한 모든 쌍의 경우에 대해 정답인 쌍의 갯수의 비율로 정의한다. 이 값은 groundtruth를 목표값, 클러스터링 결과를 예측값으로 하는 이진분류문제의 정확도(accuracy)에 해당한다. 123rand_index = np.sum(incidence) / np.prod(incidence.shape)rand_index0.68 Rand index는 0부터 1까지의 값을 가지고 1이 가장 좋은 성능을 뜻한다. Rand index의 문제점은 무작위로 클러스터링을 한 경우에도 어느 정도 좋은 값이 나올 가능성이 높다는 점이다. 즉 무작위 클러스터링 에서 생기는 Rand index의 기댓값이 너무 크다. 이를 해결하기 위해 무작위 클러스터링에서 생기는 Rand index의 기댓값을 원래의 값에서 빼서 기댓값과 분산을 재조정한 것이 adjusted Rand index다. adjusted Rand index는 무작위 클러스터링의 경우에 0이 나올 확률이 높다. 하지만 경우에 따라서는 음수가 나올 수도 있다. adjusted Rand index를 계산하려면 다음과 같은 contigency table을 만들어야 한다. contingency table은 정답과 클러스터링 결과에서 각각 같은 클러스터에 속하는 데이터의 갯수를 나타낸 것이다. 정답은 T = \\{T_1, T_2, \\dots, T_r \\}의 $r$ 개의 클러스터이고 클러스터링 결과는 C = \\{C_1, C_2, \\cdots, C_3 \\}의 $s$ 개의 클러스터라고 가정한다. \\begin{array}{c|cccc|c} T \\; \\backslash \\; C &amp; C_1&amp; C_2&amp; \\ldots&amp; C_s&amp; \\text{소계} \\\\ \\hline T_1&amp; n_{11}&amp; n_{12}&amp; \\ldots&amp; n_{1s}&amp; a_1 \\\\ T_2&amp; n_{21}&amp; n_{22}&amp; \\ldots&amp; n_{2s}&amp; a_2 \\\\ \\vdots&amp; \\vdots&amp; \\vdots&amp; \\ddots&amp; \\vdots&amp; \\vdots \\\\ T_r&amp; n_{r1}&amp; n_{r2}&amp; \\ldots&amp; n_{rs}&amp; a_r \\\\ \\hline \\text{소계}&amp; b_1&amp; b_2&amp; \\ldots&amp; b_s&amp; \\end{array} $n_{ij}$: 정답에서는 클러스터 $T_i$ 에 속하고 클러스터링 결과에서는 클러스터 $C_j$ 에 속하는 데이터의 수 $a_i = \\sum_{j=1}^s n_{ij}$ $b_j = \\sum_{i=1}^r n_{ij}$ 무작위 클러스터링의 rand index 기댓값을 구하는 공식을 적용하면 adjusted Rand index값이 다음처럼 정의된다. \\text{ARI} = \\frac{ \\overbrace{\\sum_{ij} \\binom{n_{ij}}{2}}^\\text{Index} - \\overbrace{[\\sum_i \\binom{a_i}{2} \\sum_j \\binom{b_j}{2}] / \\binom{n}{2}}^\\text{기댓값} }{ \\underbrace{\\frac{1}{2} [\\sum_i \\binom{a_i}{2} + \\sum_j \\binom{b_j}{2}]}_\\text{최댓값} - \\underbrace{[\\sum_i \\binom{a_i}{2} \\sum_j \\binom{b_j}{2}] / \\binom{n}{2}}_\\text{기댓값} }위에서 예로 들었던 타원형 데이터 예제에 대해 여러가지 클러스터링 방법을 적용하였을때 adjusted Rand index 값을 계산해보면 DBSCAN과 Spectral Clustering의 값이 높게 나오는 것을 확인할 수 있다. scikit-learn 패키지의 metrics.cluster 서브패키지는 adjusted_rand_score 명령을 제공한다. 123456789101112131415161718from sklearn.metrics.cluster import adjusted_rand_scoreX, y_true = anisotropicX = StandardScaler().fit_transform(X)for name, algorithm in clustering_algorithms: with ignore_warnings(category=UserWarning): algorithm.fit(X) if hasattr(algorithm, 'labels_'): y_pred = algorithm.labels_.astype(np.int) else: y_pred = algorithm.predict(X) print(\"&#123;:25s&#125;: ARI=&#123;:5.3f&#125;\".format(name, adjusted_rand_score(y_true, y_pred))) K-Means : ARI=0.607DBSCAN : ARI=0.975Spectral Clustering : ARI=0.959Hierarchical Clustering : ARI=0.685Affinity Propagation : ARI=0.617 Adjusted Mutual Informationmutual information은 두 확률변수간의 상호 의존성을 측정한 값이다. 클러스터링 결과를 이산확률변수라고 가정한다. 정답은 T = \\{T_1, T_2, \\cdots, T_r \\}의 $r$ 개의 값을 가질 수 있는 이산확률변수이고 클러스터링 결과는 C = \\{C_1, C_2, \\cdots, C_s \\}의 $s$ 개의 값을 가질 수 있는 이산확률변수라고 하자. 전체 데이터의 갯수를 $N$ 이라고 하면 이산확률변수 $T$ 의 분포는 P(i) = \\dfrac{|T_i|}{N}로 추정할 수 있다. 이 식에서 $|T_i|$ 는 클러스터 $T_i$ 에 속하는 데이터의 갯수를 나타낸다. 비슷하게 이산확률변수 $C$ 의 분포는 P&#39;(j) = \\dfrac{|C_i|}{N}라고 추정하고 $T$ 와 $C$ 의 결합확률분포는 P(i, j) = \\dfrac{|\\;T_i \\;\\cap\\; C_j\\;|}{N}라고 추정한다. 여기에서 $|T_i \\cap C_j|$ 는 클러스터 $T_i$ 에도 속하고 클러스터 $C_j$ 에도 속하는 데이터의 갯수를 나타낸다. 확률변수 $T, C$ 의 mutual information은 MI(T, C) = \\sum_{i=1}^r\\sum_{j=1}^s P(i,j)로 정의한다. 만약 두 확률변수가 서로 독립이면 mutual information의 값은 0이며 이 값이 mutual information이 가질 수 있는 최소값이다. 두 확률변수가 의존성이 강할수록 mutual information은 증가한다. 또한 클러스터의 갯수가 많아질수록 mutual information이 증가하므로 올바른 비교가 어렵다. 따라서 adjusted Rand index의 경우와 마찬가지로 각 경우에 따른 mutual information의 기댓값을 빼서 재조정한 것이 adjusted mutual information이다. 다음은 위에서 예로 들었던 타원형 데이터 예제에 대해 여러가지 클러스터링 방법을 적용하였을때 adjusted mutual information 값을 계산한 결과이다. scikit-learn 패키지의 metrics.cluster 서브패키지는 adjusted_mutual_info_score 명령을 제공한다. 123456789101112131415161718from sklearn.metrics.cluster import adjusted_mutual_info_scoreX, y_true = anisotropicX = StandardScaler().fit_transform(X)for name, algorithm in clustering_algorithms: with ignore_warnings(category=UserWarning): algorithm.fit(X) if hasattr(algorithm, 'labels_'): y_pred = algorithm.labels_.astype(np.int) else: y_pred = algorithm.predict(X) print(\"&#123;:25s&#125;: ARI=&#123;:5.3f&#125;\".format(name, adjusted_mutual_info_score(y_true, y_pred)))array([[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 1, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1]]) 실루엣 계수지금까지는 각각의 데이터가 원래 어떤 클러스터에 속해있었는지 정답(groudtruth)를 알고 있는 경우를 다루었다. 하지만 이러한 정답 정보가 없다면 어떻게 클러스터링이 잘되었는지 판단할 수 있을까? 실루엣 계수(Silhouette coeffient)는 이러한 경우에 클러스터링의 성능을 판단하기 위한 기준의 하나이다. 우선 모든 데이터 쌍 $(i, j)$ 에 대해 거리(distance) 혹은 비유사도(dissimilarity)을 구한다. 이 결과를 이용하여 모든 데이터 $i$에 대해 다음 값을 구한다. $a_i$: $i$ 와 같은 클러스터에 속한 원소들의 평균 거리 $b_i$: $i$ 와 다른 클러스터 중 가장 가까운 클러스터까지의 평균 거리 실루엣 계수는 s = \\dfrac{b - a}{\\text{max}(a,b)}로 정의한다. 만약 데이터 $i$ 에 대해 같은 클러스터의 데이터가 다른 클러스터의 데이터보다 더 가깝다면 실루엣 계수는 양수가 된다. 하지만 만약 다른 클러스터의 데이터가 같은 클러스터의 데이터보다 더 가깝다면 클러스터링이 잘못된 경우라고 볼 수 있는데 이 때는 실루엣 계수가 음수가 된다. 실루엣 계수가 클수록 보다 좋은 클러스터링이라고 이야기 할 수 있다. 클러스터링 방법 중에는 클러스터의 갯수를 사용자가 정해주어야 하는 것들이 있는데 실루엣 계수는 이 경우 클러스터의 갯수를 정하는데 큰 도움이 된다. 앞에서 예로 들었던 3개의 원형 데이터에 대해 KMean 방법으로 클러스터 갯수를 바꾸어가면서 클러스터링 결과를 살펴보자. scikit-learn 패키지의 metrics 서브패키지는 실루엣 계수를 계산하는 silhouette_samples 명령을 제공한다. 1234567891011121314151617181920212223242526272829303132333435363738394041from sklearn.metrics import silhouette_samplesX = StandardScaler().fit_transform(blobs[0])colors = plt.cm.tab10(np.arange(20, dtype=int))plt.figure(figsize=(6, 8))for i in range(4): model = KMeans(n_clusters=i + 2, random_state=0) cluster_labels = model.fit_predict(X) sample_silhouette_values = silhouette_samples(X, cluster_labels) silhouette_avg = sample_silhouette_values.mean() plt.subplot(4, 2, 2 * i + 1) y_lower = 10 for j in range(i + 2): jth_cluster_silhouette_values = sample_silhouette_values[cluster_labels == j] jth_cluster_silhouette_values.sort() size_cluster_j = jth_cluster_silhouette_values.shape[0] y_upper = y_lower + size_cluster_j plt.fill_betweenx(np.arange(y_lower, y_upper), 0, jth_cluster_silhouette_values, facecolor=colors[j], edgecolor=colors[j]) plt.text(-0.05, y_lower + 0.5 * size_cluster_j, str(j + 1)) plt.axvline(x=silhouette_avg, color=\"red\", linestyle=\"--\") plt.xticks([-0.2, 0, 0.2, 0.4, 0.6, 0.8, 1]) plt.yticks([]) plt.title(\"실루엣 계수 평균: &#123;:5.2f&#125;\".format(silhouette_avg)) y_lower = y_upper + 10 plt.subplot(4, 2, 2 * i + 2) plt.scatter(X[:, 0], X[:, 1], s=5, color=colors[cluster_labels]) plt.xlim(-2.5, 2.5) plt.ylim(-2.5, 2.5) plt.xticks(()) plt.yticks(()) plt.title(\"클러스터 수: &#123;&#125;\".format(i + 2))plt.tight_layout()plt.show()","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Clustering","slug":"Math/Clustering","permalink":"https://p829911.github.io/categories/Math/Clustering/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Clustering","slug":"Clustering","permalink":"https://p829911.github.io/tags/Clustering/"}]},{"title":"dark sky 사이트를 이용한 날씨 크롤링","slug":"dark-sky-사이트를-이용한-날씨-크롤링","date":"2019-01-01T09:45:00.000Z","updated":"2019-01-01T09:46:24.182Z","comments":true,"path":"2019/01/01/dark-sky-사이트를-이용한-날씨-크롤링/","link":"","permalink":"https://p829911.github.io/2019/01/01/dark-sky-사이트를-이용한-날씨-크롤링/","excerpt":"","text":"https://darksky.net/dev 다음 사이트를 이용해 api로 날씨 데이터를 크롤링 해 볼 것이다. dark sky api는 전 세계 현재/과거/미래에 관련된 날씨와 관련된 많은 데이터들을 제공한다. 사이트에 가입 후 console로 들어가면 다음과 같은 창이 나타난다. Your Secret Key에 있는 key를 사용하여 dark sky로 쿼리를 날려야 한다. dark sky api 는 하루에 1000건의 무료 call을 제공하고 있으며 1건이 추가 될 때마다 $0.0001를 받고 있다. 1000건이 넘는 요청을 해야 할 경우 account setting에서 카드 등록을 하고 하루 최대 call수를 늘려주면 요청이 정상적으로 된다. 이 포스트 에서는 구글 맵을 이용하여 지역 명으로 위도 경도를 얻은 후 그 위도 경도를 이용하여 dark sky에 요청하여 날씨 정보를 받는 실습을 진행해 보았다. 자세한 코드는 아래 링크에서 확인 가능하다. https://github.com/p829911/python_study/blob/master/crawling/dark_sky_weather_crawling.ipynb","categories":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/tags/Python/"},{"name":"Crawling","slug":"Crawling","permalink":"https://p829911.github.io/tags/Crawling/"}]},{"title":"모형 최적화","slug":"모형-최적화","date":"2019-01-01T08:13:29.000Z","updated":"2019-01-01T08:21:50.409Z","comments":true,"path":"2019/01/01/모형-최적화/","link":"","permalink":"https://p829911.github.io/2019/01/01/모형-최적화/","excerpt":"","text":"이 포스트는 fastcampus에서 강의를 하고 계시는 김도형 박사님의 강의록을 따라 쓰며 연습한 포스트입니다. 데이터 사이언스 스쿨 머신 러닝 모형이 완성된 후에는 최적화 과정을 통해 예측 성능을 향상시킨다. Scikit-Learn 의 모형 하이퍼 파라미터 튜닝 도구Scikit-Learn에서는 다음과 같은 모형 최적화 도구를 지원한다. validation_curve 단일 하이퍼 파라미터 최적화 GridSearchCV 그리드를 사용한 복수 하이퍼 파라미터 최적화 ParameterGrid 복수 파라미터 최적화용 그리드 validation_curvevalidation_curve 함수는 최적화할 파라미터 이름과 범위, 그리고 성능 기준을 param_name, param_range, scoring 인수로 받아 파라미터 범위의 모든 경우에 대해 성능 기준을 계산한다. 12345678from sklearn.datasets import load_digitsfrom sklearn.svm import SVCfrom sklearn.model_selection import validation_curvedigits = load_digits()X, y = digits.data, digits.targetparam_range = np.logspace(-6, -1, 10) 12345%%timetrain_scores, test_scores = \\ validation_curve(SVC(), X, y, param_name=\"gamma\", param_range=param_range, cv=10, scoring=\"accuracy\", n_jobs=1) 123456789101112131415161718train_scores_mean = np.mean(train_scores, axis=1)train_scores_std = np.std(train_scores, axis=1)test_scores_mean = np.mean(test_scores, axis=1)test_scores_std = np.std(test_scores, axis=1)mpl.rcParams[\"font.family\"] = 'DejaVu Sans'plt.semilogx(param_range, train_scores_mean, label=\"Training score\", color=\"r\")plt.fill_between(param_range, train_scores_mean - train_scores_std, train_scores_mean + train_scores_std, alpha=0.2, color=\"r\")plt.semilogx(param_range, test_scores_mean, label=\"Cross-validation score\", color=\"g\")plt.fill_between(param_range, test_scores_mean - test_scores_std, test_scores_mean + test_scores_std, alpha=0.2, color=\"g\")plt.legend(loc=\"best\")plt.title(\"Validation Curve with SVM\")plt.xlabel(\"$\\gamma$\")plt.ylabel(\"Score\")plt.ylim(0.0, 1.1)plt.show() GridSearchCVGridSearchCV 클래스는 validation_curve 함수와 달리 모형 래퍼(Wrapper) 성격의 클래스이다. 클래스 객체에 fit 메서드를 호출하면 grid search를 사용하여 자동으로 복수개의 내부 모형을 생성하고 이를 모두 실행시켜서 최적 파라미터를 찾아준다. 생성된 복수개와 내부 모형과 실행 결과는 다음 속성에 저장된다. grid_scores_ param_grid 의 모든 파라미터 조합에 대한 성능 결과. 각각의 원소는 다음 요소로 이루어진 튜플이다. parameters: 사용된 파라미터 mean_validation_score: 교차 검증(cross-validation) 결과의 평균값 cv_validation_scores: 모든 교차 검증(cross-validation) 결과 best_score_ 최고 점수 best_params_ 최고 점수를 낸 파라미터 best_estimator_ 최고 점수를 낸 파라미터를 가진 모형 \u0002\u0002 1234567891011121314from sklearn.model_selection import GridSearchCVfrom sklearn.pipeline import Pipelinefrom sklearn.preprocessing import StandardScalerfrom sklearn.svm import SVCpipe_svc = Pipeline([('scl', StandardScaler()), ('clf', SVC(random_state=1))])param_range = [0.0001, 0.001, 0.01, 0.1, 1.0, 10.0, 100.0, 1000.0]param_grid = [ &#123;'clf__C': param_range, 'clf__kernel': ['linear']&#125;, &#123;'clf__C': param_range, 'clf__gamma': param_range, 'clf__kernel': ['rbf']&#125;]gs = GridSearchCV(estimator=pipe_svc, param_grid=param_grid, scoring='accuracy', cv=10, n_jobs=1)%time gs = gs.fit(X, y) 1gs.cv_results_[\"params\"] 1gs.cv_results_[\"mean_test_score\"] 12print(gs.best_score_)print(gs.best_params_) ParameterGrid때로는 scikit-learn 이 제공하는 GridSearchCV 이외의 방법으로 그리드 탐색을 해야하는 경우도 있다. 이 경우 파라미터를 조합하여 탐색 그리드를 생성해 주는 명령어가 ParameterGrid 이다. ParameterGrid 는 탐색을 위한 iterator 역할을 한다. 1from sklearn.model_selection import ParameterGrid 12param_grid = &#123;'a': [1, 2], 'b': [True, False]&#125;list(ParameterGrid(param_grid)) 12param_grid = [&#123;'kernel': ['linear']&#125;, &#123;'kernel': ['rbf'], 'gamma': [1, 10]&#125;]list(ParameterGrid(param_grid)) 병렬 처리GridSearchCV 명령에는 n_jobs 라는 인수가 있다. 디폴트 값은 1인데 이 값을 증가시키면 내부적으로 멀티 프로세서를 사용하여 그리드서치를 수행한다. 만약 CPU 코어의 수가 충분하다면 n_jobs 를 늘릴수록 속도가 증가한다. 123param_grid = &#123;\"gamma\": np.logspace(-6, -1, 10)&#125;gs1 = GridSearchCV(estimator=SVC(), param_grid=param_grid, scoring='accuracy', cv=5, n_jobs=1)gs2 = GridSearchCV(estimator=SVC(), param_grid=param_grid, scoring='accuracy', cv=5, n_jobs=2) 12%%timegs1.fit(X, y) 12%%timegs2.fit(X, y)","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Classification","slug":"Math/Classification","permalink":"https://p829911.github.io/categories/Math/Classification/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Classification","slug":"Classification","permalink":"https://p829911.github.io/tags/Classification/"}]},{"title":"hexo 테마 변경하기","slug":"hexo-테마-변경하기","date":"2018-12-13T14:05:43.000Z","updated":"2018-12-13T15:23:42.000Z","comments":true,"path":"2018/12/13/hexo-테마-변경하기/","link":"","permalink":"https://p829911.github.io/2018/12/13/hexo-테마-변경하기/","excerpt":"","text":"hexo 폰트 변경 나눔스퀘어라운드 (NanumSquareRound) https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css head.ejs 수정하기1&lt;%- css(&apos;https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css&apos;) %&gt; 1vi blog/themes/hueman/layout/common/head.ejs head 부분에 추가 가운데 보면 위의 코드를 넣어 준 것을 볼 수 있다. css 적용1vi blog/themes/hueman/source/css/_variables.styl font-sans 본문 폰트 : NanumSquareRound 추가 font-mono 코드 폰트 : D2Coding을 추가 hexo theme color 변경 위와 같이 hueman 테마의 색상을 변경할 수 있다. 1vi blog/themes/hueman/source/css/_variables.styl color-default: hexo 폴더 안에 있는 _config.yml 파일에서 설정해 줄 수 있는 색상이다. 위에 사진에 보이는 follow 부분에 나타나는 색상을 적용해 줄 수 있다, 여기서 적용하지 말고 _config.yml파일에서 바꿔준다. color-header-background: 위에 보이는 파란색 영역에 색상을 지정해 줄 수 있다. color-border: 위에 보이는 노란색 영역에 색상을 지정해 줄 수 있다. color-nav-background: 검은색 영역에 색상 지정 color-footer-background: 맨 밑의 영역에 색상 지정 color-sidebar- background: sidebar의 배경색은 모바일에서는 바뀌지만, 데스크탑 사이트에서는 바뀌지 않는다 이 부분의 문제점은 좀 더 찾아봐야할 것 같다. 아래의 링크에서 색상 선택에 도움을 받을 수 있을 것이다.Hex Color Code","categories":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/tags/Git/"},{"name":"Blog","slug":"Blog","permalink":"https://p829911.github.io/tags/Blog/"}]},{"title":"entropy","slug":"entropy","date":"2018-12-13T11:18:47.000Z","updated":"2018-12-13T11:29:43.000Z","comments":true,"path":"2018/12/13/entropy/","link":"","permalink":"https://p829911.github.io/2018/12/13/entropy/","excerpt":"","text":"이 포스트는 fastcampus에서 강의를 하고 계시는 김도형 박사님의 강의록을 따라 쓰며 연습한 포스트입니다. 데이터 사이언스 스쿨 엔트로피의 정의$Y = 0$ 또는 $Y=1$인 두 가지 값을 가지는 확률 분포가 다음과 같이 세 종류가 있다고 하자 확률 분포 $Y_1$: $P(Y=0) = 0.5, P(Y=1) = 0.5$ 확률 분포 $Y_2$: $P(Y=0) = 0.8, P(Y=1) = 0.2$ 확률 분포 $Y_3$ : $P(Y=0) = 0.8, P(Y=1) = 0.2$ 이 확률 값이 베이지안 확률이라면 확률 분포 $Y_1$은 $y$값에 대해 아무것도 모르는 상태, $Y_3$은 $y$값이 0이라고 100% 확신하는 상태, $Y_2$은 $y$값이 0이라고 믿지만 아닐 수도 있다는 것을 아는 상태를 나타내고 있을 것이다. 확률 분포들이 가지는 확신의 정도를 수치로 표현하는 것을 엔트로피(entropy)라고 한다. 확률 변수의 여러가지 값이 나올 확률이 대부분 비슷한 경우에는 엔트로피가 높아진다. 반대로 특정한 값이 나올 확률이 높아지고 나머지 값의 확률은 낮아진다면 엔트로피가 작아진다. 물리학에서는 상태가 분산되어 있는 정도를 엔트로피로 정의한다. 여러가지로 고루 분산되어 있을 수 있으면 엔트로피가 높고 특정한 하나의 상태로 몰려있으면 엔트로피가 낮다. 확률분포의 엔트로피는 물리학의 엔트로피 용어를 빌려온 것이다. 엔트로피는 수학적으로 다음과 같이 정의한다 확률변수 $Y$가 베르누이나 카테고리 분포와 같은 이산 확률변수이면 H[Y] = -\\sum_{k=1}^K P(y_k) log_2 P(y_k)이 식에서 $K$는 $X$가 가질 수 있는 클래스의 수이고 $P(y)$는 확률질량함수이다. 확률변수 $Y$가 연속 확률변수이면 H[Y] = - \\int_{-\\infty}^{\\infty} p(y) log_2p(y)\\;dy이 식에서 $P(y)$는 확률밀도함수이다. 로그의 밑(base)이 2로 정의된 것은 정보통신과 관련을 가지는 역사적인 이유 때문이다. 위에서 예를 든 $Y_1$, $Y_2$, $Y_3$에 대해 엔트로피를 구하면 다음과 같다. \\begin{eqnarray} H[Y_1] &=& -\\frac{1}{2}log_2\\frac{1}{2} - \\frac{1}{2}log_2\\frac{1}{2} &=& 1 \\\\\\\\ H[Y_2] &=& -\\frac{8}{10}log_2\\frac{8}{10} - \\frac{2}{10}log_2\\frac{2}{10} &=& 0.72 \\\\\\\\ H[Y_3] &=& -1log_21 - 0log_20 &=& 0 \\end{eqnarray}엔트로피 계산에서 $p(y) = 0$인 경우에는 다음과 같은 극한값을 사용한다. 이 값은 로피탈의 정리에서 구할 수 있다. 엔트로피의 성질확률변수가 결정론적이면 확률분포에서 특정한 하나의 값이 나올 확률이 1이다. 이 때 엔트로피는 0이 되고 이 값은 엔트로피가 가질 수 있는 최솟값이다. 반대로 엔트로피의 최대값은 이산 확률변수의 클래스의 갯수에 따라 달라진다. 만약 이산 확률변수가 가질 수 있는 클래스가 $2^K$개이고 이산 확률변수가 가질 수 있는 엔트로피의 최대값은 각 클래스가 모두 같은 확률을 가지는 때이다. 이 때 엔트로피의 값은 H = -\\frac{2^K}{2^K}log_2\\frac{1}{2^K} = K이다. 엔트로피와 정보량엔트로피는 확률변수가 담을 수 있는 정보의 양을 의미한다고 볼 수도 있다. 확률변수가 담을 수 있는 정보량(information)이란 확률변수의 표본값을 관측해서 얻을 수 있는 추가적인 정보의 종류를 말한다. 엔트로피가 0이면 확률변수는 결정론적이므로 확률 변수의 표본값은 항상 같다. 따라서 확률 변수의 표본값을 관측한다고 해도 우리가 얻을 수 있는 추가 정보는 없다. 반대로 엔트로피가 크다면 확률변수의 표본값이 가질 수 있는 경우의 수가 증가하므로 표본값을 실제로 관측하기 전까지는 아는 것이 거의 없다. 반대로 말하면 확률변수의 표본값이 우리에게 가져다 줄 수 있는 정보의 양이 많다. 엔트로피와 무손실 인코딩엔트로피는 원래 통신 분야에서 데이터가 가지고 있는 정보량을 계산하기 위해 고안되었다. 예를 들어 4개의 알파벳 A, B, C, D로 씌어진 문서가 있다고 하자. 이 문서를 0과 1로 이루어진 이진수로 변환할 때 일반적인 경우라면 다음과 같이 인코딩을 할 것이다. A = “00” B = “01” C = “10” D = “11” 이렇게 인코딩을 하면 1,000 글자로 이루어진 문서는 이진수 2,000개가 된다. 만약 문서에서 각 알파벳이 나올 확률이 동일하지 않고 다음과 같다고 가정하다. \\Big\\{ \\dfrac{1}{2}, \\dfrac{1}{4}, \\dfrac{1}{8}, \\dfrac{1}{8} \\Big\\}이 때는 다음과 같이 가변길이 인코딩(variable length encoding)을 하면 인코딩된 이진수의 수를 줄일 수 있다. A = “0” B = “10” C = “110” D = “111” 인코딩된 이진수의 숫자는 다음 계산에서 약 1,750개가 됨을 알 수 있다. \\left(1000 \\times \\frac{1}{2}\\right) \\cdot 1 + \\left(1000 \\times \\frac{1}{4}\\right) \\cdot 2 + \\left(1000 \\times \\frac{1}{8}\\right) \\cdot 3 + \\left(1000 \\times \\frac{1}{8}\\right) \\cdot 3 = 17501.75는 알파벳 한 글자를 인코딩하는데 필요한 평균 비트(bit)수이며 확률변수의 엔트로피 값과 같다. H = -\\frac{1}{2}log_2\\frac{1}{2}-\\frac{1}{4}log_2\\frac{1}{4}-\\frac{2}{8}log_2\\frac{1}{8} = 1.75엔트로피의 추정확률 변수 모형, 즉 이론적인 확률 밀도(질량) 함수가 아닌 실제 데이터가 주어진 경우에는 확률질량함수를 추정하여 엔트로피를 계산한다. 예를 들어 데이터가 모두 80개가 있고 그 중 $Y=0$인 데이터가 40개, $Y=1$인 데이터가 40개 있는 경우는 엔트로피가 1이다. P(y=0) = \\frac{40}{80} = \\frac{1}{2} \\\\ \\\\ P(y=1) = \\frac{40}{80} = \\frac{1}{2} \\\\ \\\\ H[Y] = -\\frac{1}{2}log_2\\left(\\frac{1}{2}\\right) -\\frac{1}{2}log_2\\left(\\frac{1}{2}\\right) = \\frac{1}{2} + \\frac{1}{2} = 1만약 데이터가 모두 60개가 있고 그 중 $Y=0$인 데이터가 20개, $Y=1$인 데이터가 40개 있는 경우는 엔트로피가 약 0.92이다. P(y=0) = \\frac{20}{60} = \\frac{1}{3}\\\\ P(y=1) = \\frac{40}{60} = \\frac{2}{3}\\\\ H[Y] = -\\frac{1}{3}log_2\\left(\\frac{1}{3}\\right)-\\frac{2}{3}log_2\\left(\\frac{2}{3}\\right) = 0.92지니불순도엔트로피와 유사한 개념으로 지니불순도(Gini Impurity)라는 것이 있다. 지니불순도는 엔트로피처럼 확률분포가 어느쪽에 치우쳐있는가를 재는 척도지만 로그를 사용하지 않으므로 계산량이 더 적어 엔트로피 대용으로 많이 사용된다. G[Y] = \\sum_{k=1}^K P(y_k)(1-P(y_k))1234567891011P0 = np.linspace(0.001, 1 - 0.001, 1000)P1 = 1 - P0H = - P0 * np.log2(P0) - P1 * np.log2(P1)G = (P0 * (1 - P0) + P1 * (1 - P1)) # 엔트로피와 높이를 맞춰주기 위해 스케일링 하는 경우도 있다. 여기서는 G 앞에 2를 곱해준다.plt.plot(P0, H, \"-\", label=\"엔트로피\")plt.plot(P0, G, \"--\", label=\"지니불순도\")plt.legend()plt.xlabel(\"P(0)\")plt.show() 결합 엔트로피두 이산확률변수 $X, Y$에 대해 결합 엔트로피(joint entropy)는 다음처럼 정의한다. H[X,Y] = -\\sum_{i=1}^{K_x}\\sum_{j=1}^{K_y}P(x_i,y_j)log_2P(x_i,y_j)연속확률변수의 경우에는 다음처럼 정의한다. H[X,Y] = - \\int_x\\int_y p(x,y)log_2p(x,y)\\; dxdy조건부 엔트로피조건부 엔트로피는 상관관계가 있는 두 확률변수 $X,Y$가 있고 $X$의 값을 안다면 $Y$의 확률변수가 가질 수 있는 정보의 양을 뜻한다. 수학적으로는 다음과 같이 정의한다. H[Y \\mid X] = - \\sum_{i=1}^{K_x} \\sum_{j=1}^{K_y} P(x_i,y_j)\\,log2\\, P(y_j \\mid x_i)연속확률변수의 경우에는 다음처럼 정의한다. H[Y \\mid X] = - \\int_x \\int_y p(x,y) \\, log_2\\,p(y \\mid x)\\; dxdy조건부 엔트로피는 조건부 확률 분포의 정의를 사용하여 다음과 같이 고칠 수 있다. H[Y \\mid X] = - \\sum_{i=1}^{K_x} \\,P(x_i)\\,H[Y \\mid X=x_i]연속확률변수의 경우에는 다음과 같다. H[Y \\mid X] = - \\int_{x} \\,p(x) \\,H[Y \\mid X=x] \\; dx크로스 엔트로피두 확률분포 $p(x), p(y)$의 크로스 엔트로피(cross entropy) $H[p,q]$는 다음과 같이 정의한다. 크로스 엔트로피의 경우에는 같은 확률변수에 대한 두 개의 추정 확률분포를 비교하는데 주로 쓰이기 때문에 표기를 할 땐 결합 엔트로피처럼 확률변수를 인수로 사용하지 않고 확률분포를 인수로 사용한다는 점에 주의해라 H[P,Q] = -\\sum_{k=1}^K P(y_k)\\, \\log_2\\, Q(y_k)또는 H[p,q] = - \\int_yp(y)\\log_2\\,q(y)\\,dy크로스 엔트로피는 확률분포의 차이를 정량화한 값이지만 기준이 되는 분포가 $p$로 고정되어 있다. 즉 $p$와 $q$가 바뀌면 값이 달라진다. H[p,q] \\neq H[q,p]크로스 엔트로피는 분류 모형의 성능을 측정하는데 사용된다. $Y$가 0 또는 1이라는 값만 가지는 이진 분류 문제를 예로 들어보자. $P_Y$는 $X$가 정해졌을 때 실제 $Y$가 가지는 분포를 뜻한다. $X$가 정해지면 $Y$는 확실히 0이거나 확실히 1이다. 즉, $P_Y$는 (0,1) 또는 (1,0)이 된다. 하지만 예측값 $\\hat{Y}$의 분포 $Q_{\\hat{Y}}$는 모수가 $\\mu$인 베르누이 분포이다. 즉 $Q_{\\hat{Y}}$는 $(1-\\mu, \\mu)$이다. 특정한 $X$에 대해 $P$와 $Q$의 크로스 엔트로피는 H[P,Q] = \\begin{cases} & -\\log_2 (1-\\mu) & Y=0 \\text{일 때} \\\\ & -\\log_2 \\mu & Y=1 \\text{일 때} \\end{cases}가 된다. $Y = 0$일 때 $\\mu$가 커질수록 즉, 예측이 틀릴수록 $-\\log_2 (1-\\mu)$의 값도 커진다. $Y = 1$일 때, $\\mu$가 작아질수록 즉, 예측이 틀릴수록 $-\\log_2(\\mu)$의 값도 커진다. 따라서 위 값은 예측의 틀린정도를 나타내는 오차 함수의 역할을 할 수 있다. 모든 데이터에 대해 이 값의 평균을 구하면 다음 식으로 표현할 수 있다. H[P,Q] = - \\frac{1}{N} \\sum_{i=1}^N(y_i \\log_2 \\mu_i + (1-y_i)\\log_2 (1-\\mu))같은 방법으로 이진 분류가 아닌 다중 분류에서도 크로스 엔트로피를 오차 함수로 사용할 수 있다. 쿨백-라이블러 발산쿨백-라이블러 발산(Kullback-Leibler divergence)은 두 확률분포 $p(y), q(y)$의 차이를 정량화하는 방법의 하나이다. 다음과 같이 정의한다. \\begin{eqnarray} KL(P || Q) &=& H[P,Q] - H[P] &=& \\sum_{i=1}^{K} P(y_i) \\log_2 \\left(\\dfrac{P(y_i)}{Q(y_i)}\\right) \\end{eqnarray}또는 \\begin{eqnarray} KL(p || q) &=& H[p, q] - H[p] &=& \\int p(y) \\log_2 \\left(\\dfrac{p(y)}{q(y)}\\right) dy \\end{eqnarray}쿨백-라이블러 발산은 크로스 엔트로피에서 기준이 되는 분포의 엔트로피 값을 뺀 값이므로 상대 엔트로피(relative entropy)라고도 한다. 그 값은 항상 양수이며 두 확률분포 $p(x), q(x)$가 완전히 같을 경우에만 0이 된다.","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Classification","slug":"Math/Classification","permalink":"https://p829911.github.io/categories/Math/Classification/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Classification","slug":"Classification","permalink":"https://p829911.github.io/tags/Classification/"}]},{"title":"mysql install","slug":"mysql-install","date":"2018-12-06T12:52:38.000Z","updated":"2018-12-06T12:54:22.000Z","comments":true,"path":"2018/12/06/mysql-install/","link":"","permalink":"https://p829911.github.io/2018/12/06/mysql-install/","excerpt":"","text":"mysql install1sudo apt install -y mysql-server 1sudo mysql_secure_installaion press y|Y for Yes, any other key for No: n remove anonymous users? y disallow root login remotely? n remove test database and access to it? n reload privilege tables now? y success! 1sudo mysql passward 설정1234SELECT user,authentication_string,plugin,host FROM mysql.user;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_passwordBY &apos;dss&apos;;FLUSH PRIVILEGES; root 사용자로 접속12mysql -u root -p# 패스워드 입력 상태확인bash 창에서 1sudo systemctl status mysql active 확인 외부접속 설정1sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf bind-address = 0.0.0.0으로 수정 외부접속이 허용되도록 mysql 설정 1mysql -u root -p 1grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;&lt;password&gt;&apos;; 포트 활성화AWS서버에서 3306포트 활성화 재시작으로 설정 적용 1sudo systemctl restart mysql.service mysql에서 접속 import sql file바로 데이터 베이스 넣기 1mysql -u root -p world &lt; world.sql mysql shell에서 넣기 1234create database world;use world;source world.sql;show tables; Mysql 삭제12345sudo apt remove --purge mysql-server mysql-clientsudo rm -rf /etc/mysql/var/lib/mysqlsudo apt autoremovesudo apt autocleansudo apt purge mysql*","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://p829911.github.io/categories/Mysql/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"},{"name":"Mysql","slug":"Mysql","permalink":"https://p829911.github.io/tags/Mysql/"}]},{"title":"다중 선형 회귀","slug":"regression","date":"2018-12-06T12:33:47.000Z","updated":"2018-12-13T11:22:47.000Z","comments":true,"path":"2018/12/06/regression/","link":"","permalink":"https://p829911.github.io/2018/12/06/regression/","excerpt":"","text":"다중 선형 회귀 설명변수들 $X_1, X_2, \\cdots, X_p$ 중 적어도 하나는 반응변수를 예측하는데 유용한가? $Y$를 설명하는 데 모든 설명변수들이 도움이 되는가? 또는 설명변수들의 일부만이 유용한가? 모델은 데이터에 얼마나 잘 맞는가? 주어진 설명변수 값들에 대해 어떤 반응변수 값을 예측해야 하고 그 예측은 얼마나 정확한가? 1. 반응변수와 설명변수 사이에 상관관계가 있는가? 단순선형회귀에서 반응변수와 설명변수 사이에 상관관계가 있는지는 단순히 $\\beta_1 = 0$인지 검사하면 결정할 수 있다. $p$개 설명변수가 있는 다중회귀에서는 모든 회귀계수들이 영인지, 즉 $\\beta_1 = \\beta_2 = \\cdots = \\beta_p =0$인지를 검사해야 한다. 단순선형회귀에서와 같이 이 질문에 답하기 위해 가설검정을 사용한다. 귀무가설 H_0 : \\beta_1 = \\beta_2 = \\cdots = \\beta_p = 0대립가설 H_a: \\text{적어도 하나의 }\\beta_j\\text{는 영이 아니다.}이러한 가설 검정은 $F$-통계량을 계산함으로써 이루어진다. F = \\dfrac{(\\text{TSS} - \\text{RSS})/p}{\\text{RSS}/(n-p-1)}단순선형회귀에서와 같이 $\\text{TSS} = \\sum(y_i-\\bar{y})^2$ 이고 $\\text{RSS} = \\sum(y_i - \\hat{y_i})^2$이다. 만약 선형 모델의 가정이 같다면 다음이 성립함을 보여줄 것이다. E[\\,\\text{RSS}\\, / \\,(n-p-1)\\,] = \\sigma^2또한 귀무가설 $H_0$이 참이면 다음이 성립함을 보여줄 수도 있다. E[\\,(\\text{TSS} - \\text{RSS})\\,/\\,p\\,] = \\sigma^2그러므로, 반응변수와 설명변수들 사이에 상관관계가 없는 경우(RSS가 커질때 TSS와 거의 가까움) $F$- 통계량이 1에 매우 가까운 값이라고 기대할 수 있을 것이다. 반면에 만약 대립가설 $H_a$가 참이면 $E[\\,(\\text{TSS}-\\text{RSS})\\,/\\, p\\,] &gt; \\sigma^2$이고 그래서 $F$의 기대값은 1보다 크다. $H_0$을 기각하고 상관관계가 있다고 결론을 내릴 수 있으면 $F$-통계량이 얼마나 커야될까? $n\\text{과} p$값에 따라 다르다. $n$이 큰 경우에는 $F$-통계량이 1보다 약간만 크면 $H_0$에 반하는 증거가 된다. $n$이 작은 경우 $H_0$를 기각하려면 더 큰 $F$-통계량이 필요하다. 2. 중요 변수의 결정 모든 설명변수가 반응변수와 상관성이 있을 수도 있다. 하지만 대부분의 경우 설명변수들의 일부(서브셋)만이 반응변수와 상관관계가 있다. 상관성이 있는 설명변수만으로 모델 적합을 수행하기 위해 어느 설명변수가 반응변수와 상관성이 있는지 결정하는 것을 변수선택이라고 한다. 모델의 질 평가 맬로우즈(Mallows) $C_p$ AIC (Akaike information criterion) BIC (Bayesian information criterion) 수정된 $R^2$ $p$개 변수들의 일부를 포함하는 총 모델의 경우의 수는 $2^p$개에 이른다. 심지어 $p$가 크지 않더라도 모든 가능한 설명변수들의 부분집합을 다 시험해 보는 것은 현실적으로 어렵다. 예를 들어 $p = 2$인 경우 $2^2 = 4$모델을 고려하면 된다. 그러나 $p=30$이면 고려해야 하는 모델 수는 $2^{30} = 1,073,741,824$개로 늘어나 현실적으로 불가능에 가깝다. 그러므로 $p$가 아주 작은 경우가 아니면 $2^p$개 모델 모두를 고려할 수는 없고, 대신에 더 작은 수의 고려할 모델 집합을 선택하는 자동화되고 효과적인 기법이 필요하다. 이 목적을 위한 3가지 고전적인 기법은 아래와 같다. 전진선택: 이 방법은 절편만 포함하고 설명변수는 없는 영모델(null model)을 가지고 시작한다. $p$개의 단순 선형 회귀를 적합하여 가장 낮은 $RSS$가 발생되는 변수를 영모델에 추가한다. 그런 다음 새로운 새로운 2-변수 모델에 대해 가장 낮은 $RSS$가 생기는 변수를 모델에 추가한다. 이런 방식으로 어떤 정지규칙(stopping rule)을 만족할 때까지 계속된다. 후진선택(Backward selection): 이 방법은 모델의 모든 변수를 가지고 시작하여 가장 큰 $p$-값을 가지는 변수, 즉 통계적으로 중요도가 가장 낮은 변수를 제외한다. 그 다음에 새로운 (p-1)-변수의 모델을 적합하고 $p$-값이 가장 큰 변수를 제외한다. 이 과정을 정지 규칙이 만족될 때까지 계속한다. 예를 들어 모든 남아있는 변수들의 $p$-값이 어떤 임계치보다 작으면 이 과정을 중지한다. 혼합선택(Mixed selection): 이것은 전진선택과 후진선택을 결합한 것이다. 전진선택처럼 변수가 없는 모델로 시작하여 최상의 적합을 제공하는 변수를 하나씩 추가한다. 새로운 설명변수들이 모델에 추가됨에 따라 변수들에 대한 $p$-값이 커질 수 있다. 그러므로 모델의 변수들 중 어느 하나에 대한 $p$-값이 어떤 임계치보다 커지면 그 변수를 모델에서 제외한다. 이러한 전진선택 및 후진선택 단계를 계속하여 모델에 포함되는 모든 변수들은 충분히 작은 $p$-값을 가지고 모델에서 제외된 변수들은 만약 모델에 추가될 경우 $p$-값이 크게 될 때 중지한다. 후진 선택법은 만약 p &gt; n 이면 사용할 수 없지만 전진선택법은 항상 사용할 수 있다. 전진선택법은 그리디(greedy)방식이다. 그래서 초기에 포함된 변수들이 나중에는 유효하지 않을 수 있다. 이 문제는 혼합선택법으로 선택할 수 있다. 3. 모델 적합 모델 적합의 수치적 측도로 가장 흔히 사용되는 두가지는 $RSE$와 $R^2$(설명되는 분산의 비율)이다. 이 값들은 단순선형회귀에서와 같은 방식으로 계산되고 해석된다. 단순회귀에서 $R^2$은 반응변수와 설명변수의 상관계수의 곱이다. 다중 선형회귀에서 이것은 반응변수와 적합된 선형모델 사이의 상관계수의 제곱인 $Cor(Y,\\hat{Y})^2$과 동일하다. 사실 적합된 선형모델은 모든 가능한 선형모델 중에서 이 상관계수가 최대로 되는 것이다. 1에 가까운 $R^2$값은 모델이 반응변수 내 분산의 많은 부분을 설명한다는 것을 나타낸다. 모델에 더 많은 변수가 추가되면 비록 추가된 변수와 반응변수의 상관관계가 아주 약하더라도 $R^2$은 항상 증가할 것이다. 이것은 최소제곱 방정식에 변수를 추가하면 훈련 데이터(반드시 검정 데이터일 필요는 없다.)를 더 정확하게 적합할 수 있다는 사실 때문이다. 특정 독립 변수를 추가했을 때 $R^2$이 약간만 증가한다는 사실은 그 독립 변수가 모델에서 제외될 수 있다는 추가적인 증거가 된다. 모델에 그 독렵변수를 포함하는 것은 독립적인 검정표본에 대한 과적합으로 인해 좋지 않은 결과를 초래할 가능성이 높을 것이다. 4. 예측 다중선형모델 적합을 수행하였으면 $\\hat{y} = \\hat{\\beta_0} + \\hat{\\beta_1}x_1 + \\hat{\\beta_2}x_2 + \\cdots + \\hat{\\beta_p}x_p$을 적용하여 설명변수 $X_1, X_2, \\cdots, X_p$의 값에 기초하여 반응 변수 $Y$를 예측하는 것은 어렵지 않다. 하지만, 이러한 예측에는 세 가지 명확하지 않은 것이 연관되어 있다. 계수추정 $\\hat{\\beta_0}, \\hat{\\beta_1}, \\cdots, \\hat{\\beta_p}$는 $\\beta_0,\\beta_1,\\cdots, \\beta_p$에 대한 추정값이다. 즉 아래 최소제곱평면은 \\hat{Y} = \\hat{\\beta_0} + \\hat{\\beta_1}X_1 + \\cdots + \\hat{\\beta_p}X_p다음의 실제 모회귀평면에 대한 추정값이다. f(X) = \\beta_0 + \\beta_1X_1 + \\cdots + \\beta_pX_p계수추정의 부정확도는 2장의 축소가능 오차(reducible error)와 관련된다. 신뢰구간을 계산하여 $\\hat{Y}$가 $f(x)$에 얼마나 가까운지 결정할 수 있다. 물론, 실제로 $f(x)$에 대해 선형 모델을 가정하는 것은 거의 항상 현실에 대한 근사이다. 따라서 모델 편향(model bias)이라고 하는 잠재적으로 축소가능한 오차의 또 다른 출처가 있다. 그러므로 선형모델을 사용할 때 실제 표면에 대한 최상의 선형 근사를 추정하는 것이다. 하지만, 여기서는 이러한 차이를 무시하고 마치 선형 모델이 올바른 것으로 간주한다. 심지어 $f(x)$를 알아도 - $\\beta_0, \\beta_1, \\cdots, \\beta_p$에 대한 실제 값을 알아도 - 모델의 랜덤오차 때문에 반응변수 값을 완벽하게 예측할 수는 없다. 2장에서 이 오차를 축소불가능 오차(irreducible error)라고 하였다. 선형 모델의 확장표준선형회귀모델 $Y = \\beta_0 + \\beta_1X1 + \\beta_2X2 + \\cdots + \\beta_pX_p + \\epsilon$ 는 해석이 가능한 결과를 제공하며 많은 현실적인 문제에 대해서도 잘 동작한다. 하지만 이것은 실제로는 성립되지 않는 몇 가지 아주 제한적인 가정을 사용한다. 가장 중요한 가정 중 두 가지는 설명변수와 반응변수 사이의 관계는 가산적(additive)이고 선형적이라는 것이다. 가산성 가정: 설명변수 $X_j$의 변화가 반응변수 $Y$에 미치는 영향은 다른 설명변수 값에 독립적이다. 선형성 가정: $X_j$의 한 유닛 변화로 인한 $Y$의 변화는 $X_j$의 값에 관계없이 상수이다. 가산성 가정의 제거 Advertising 자료 분석에서 TV와 radio 둘 다 sales와 상관관계가 있다고 결론지었다. 이러한 결론의 근거가 되는 선형모델들은 한 광고매체의 지출 증가가 sales에 미치는 영향은 다른 매체에 대한 지출과 무관하다고(독립적이라고) 가정한다. 하지만, 이런 단순한 모델은 맞지 않을 수 있다. 라디오 광고 지출이 실제로 TV 광고의 효과를 증가시켜 TV에 대한 기울기 항이 라디오 지출이 늘어남에 따라 증가해야 한다고 해보자. 이러한 경우, 주어진 10만 달러의 고정 광고예산을 라디오와 TV에 절반씩 지출하는 것이 전체 예산을 TV 또는 라디오 어느 한쪽에 모두 사용하는 것보다 판매량 증가가 더 클 수 있다. 이것을 마케팅에서는 시너지 효과 라 하고 통계학에서는 상호작용 효과 라 한다. 두 개의 변수를 가지는 표준 선형회귀모델을 고려해보자 Y = \\beta_0+\\beta_1X_1+\\beta_2X_2+\\epsilon이 모델에 따르면 $X_1$이 한 유닛 증가하면 $Y$는 평균 $\\beta_1$유닛만큼 증가할 것이다. $X_2$의 존재는 이 사실을 변경하지 않는다. 즉, $X_2$의 값에 관계없이 $X_1$이 한 유닛 증가하면 $Y$는 $\\beta_1$ 유닛 증가할 것이다. 상호작용 효과를 포함하도록 이 모델을 확장하는 한 가지 방법은 상호작용 항이라 불리는 세 번째 설명변수를 포함하는 것이다. 상호작용 항은 $X_1$과 $X_2$의 곱으로 구성된다. 그러면 결과 모델은 다음과 같이 표현 된다. Y = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + \\beta_3X_1X_2 + \\epsilon위의 식은 아래와 같이 다시 쓸 수 있다. \\begin{eqnarray} Y &=& \\beta_0 + (\\beta_1 + \\beta_3X_2)X_1 + \\beta_2X_2 + \\epsilon\\\\ &=& \\beta_0 + \\tilde{\\beta_1}X_1 + \\beta_2X_2 + \\epsilon \\end{eqnarray}여기서 $\\tilde{\\beta_1} = \\beta_1 + \\beta_3X_2$이다. $\\tilde{\\beta_1}$은 $X_2$에 따라 변하므로 $Y$에 대한 $X_1$의 효과는 더이상 상수가 아니다. $X_2$를 조정하면 $Y$에 대한 $X_1$의 효과가 변할 것이다. 이것은 실제 상관관계는 가산적이지 않다는 것이 명백하다. 가끔씩 상호작용 항은 매우 작은 $p$-값을 가지지만 관련된 주효과는 그렇지 않은 경우도 있다. 계층적 원리 에 의하면, 만약 모델에 상호작용을 포함하면 주효과는 그 계수와 연관된 $p$-값이 유의하지 않더라도 모델에 포함해야 한다. 다시 말해, 만약 $X_1$과 $X_2$사이의 상호작용이 중요한 것 같으면 $X_1$과 $X_2$의 계수 추정치가 큰 $p$-값을 가져도 모델에 $X_1$과 $X_2$를 포함해야 한다. 이유는 만약 $X_1 \\times X_2 $가 반응변수와 상관관계가 있으면 $X_1$또는 $X_2$의 계수가 영인지는 관심이 없다. 또한 $X_1 \\times X_2$는 보통 $X_1$ 및 $X_2$와 상관되어 있어 이들을 제외하는 것은 상호작용의 의미를 바꾸는 경향이 있다. 상호작용의 개념은 질적 변수 또는 양적 변수와 질적 변수의 조합에도 적용된다. 사실, 질적 변수와 양적 변수 사이의 상호작용을 해석하기는 특히 쉽다. 상호작용 항이 없을 경우 모델은 다음 형태를 가진다. \\begin{eqnarray} \\text{balance}_i &\\approx& \\beta_0 + \\beta_1 \\times \\text{income}_i + \\begin{cases}\\beta_2 & i\\text{번째 사람이 학생인 경우} \\\\ 0 & i\\text{번째 사람이 학생이 아닌 경우} \\end{cases} \\\\\\\\ &=& \\beta_1 \\times \\text{income}_i + \\begin{cases}\\beta_0 + \\beta_2 & i\\text{번째 사람이 학생인 경우} \\\\ \\beta_0 & i\\text{번째 사람이 학생이 아닌 경우}\\end{cases} \\end{eqnarray}이것은 두 개의 평행한 직선을 데이터에 적합하는 것이다. 학생과 학생이 아닌 사람에 대한 두 직선은 다른 절편 $\\beta_0 + \\beta_2$와 $\\beta_0$을 가지지만 동일한 기울기 $\\beta_1$을 가진다. 두 직선이 평행하다는 사실이 의미하는 것은 income의 한 유닛 증가가 balance에 미치는 평균 효과는 그 사람이 학생인지 아닌지에 의존적이지 않다는 것을 의미한다. 이것은 모델이 잠재적으로 심각한 한계가 있음을 나타낸다. 왜냐하면 소득의 변화는 학생과 학생이 아닌 사람의 신용카드 대금에 아주 다른 효과를 줄 수 있기 때문이다. 이 한계는 income을 student에 대한 가변수와 곱하여 얻은 상호작용 변수를 추가함으로써 해결할 수 있다. 그러면 모델은다음과 같이 표현된다. \\begin{eqnarray} \\text{balance}_i &\\approx& \\beta_0 + \\beta_1 \\times \\text{income}_i + \\begin{cases}\\beta_2 + \\beta_3 \\times \\text{income}_i & \\text{학생인 경우}\\\\ 0 & \\text{학생이 아닌 경우}\\end{cases}\\\\ \\\\ &=& \\begin{cases}(\\beta_0 + \\beta_2) + (\\beta_1 + \\beta_3) \\times \\text{income}_i & 학생인 경우 \\\\ \\beta_0 + \\beta_1 \\times \\text{income}_i & \\text{학생이 아닌 경우}\\end{cases} \\end{eqnarray}이 경우에도 학생과 학생이 아닌 사람에 대한 회귀 직선이 다르다. 그러나 이번에는 두 직선의 절편 뿐만 아니라 기울기도 다르다. 학생인 경우, 회귀직선의 절편은 $\\beta_0 + \\beta_2$, 기울기는 $\\beta_1 + \\beta_3$이다. 학생이 아닌 경우에는 절편은 $\\beta_0$, 기울기는 $\\beta_1$이다. 이것은 소득 변화가 신용카드 대금에 미치는 영향이 학생인지의 여부에 따라 다를 수 있게 한다. 학생에 대한 기울의 기울기가 학생이 아닌 경우에 대한 것보다 작은데, 이것은 소득 증가에 따른 카드 대금의 증가가 학생인 경우 학생이 아닌 사람보다 낮다는 것을 시사한다. 비선형 상관관계","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Regression","slug":"Math/Regression","permalink":"https://p829911.github.io/categories/Math/Regression/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Regression","slug":"Regression","permalink":"https://p829911.github.io/tags/Regression/"}]},{"title":"git 설치 & 사용법","slug":"git-install-and-how-to-use","date":"2018-12-03T12:58:52.000Z","updated":"2018-12-19T05:45:28.000Z","comments":true,"path":"2018/12/03/git-install-and-how-to-use/","link":"","permalink":"https://p829911.github.io/2018/12/03/git-install-and-how-to-use/","excerpt":"","text":"git은 터미널에서 다음과 같은 명렁어로 설치 할 수 있다.1sudo apt-get install git 설치가 완료 되었으면 1git --version git config 설정 1234git config --global user.name \"username\"git config --global user.email \"github email address\"git config --global core.editor \"vim\"git config --list local에 있는 폴더와 git 저장소 연동시키기 폴더 생성 후 git init 해주기 123git initgit add.git commit -m \"contents\" git repository 생성 해 준 후 12git remote add origin https://github.com/username/repo.gitgit push origin master 위의 코드에서 origin이라는 부분은 사용자가 지정할 수 있지만, 보통 origin이라고 써줌 git 에서 저장소를 clone 할 때는 자동적으로 origin이라고 지정 된다. git 저장소 local 폴더로 복제하기1git clone https://github.com/username/repo.git 개인적으로는 git remote 보다 git clone해서 사용하는 것이 더 편하다. branch소프트웨어를 개발할 때 개발자들은 동일한 소스코드를 함께 공유한다. 동일한 소스코드 위에서 서로 다른 작업을 할 때는 각각 서로 다른 버전의 코드가 만들어 질 수 밖에 없다.이럴 때, 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능이 바로 ‘브랜치(Branch)’이다.이렇게 분리된 작업 영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다. 브랜치란 독립적으로 어떤 작업을 진행하기 위한 개념이다. 필요에 의해 만들어지는 각각의 브랜치는 다른 브랜치의 영향을 받지 않기 때문에, 여러 작업을 동시에 진행할 수 있다. 또한 이렇게 만들어진 브랜치는 다른 브랜치와 병합(Merge)함으로써, 작업한 내용을 다시 새로운 하나의 브랜치로 모을 수 있다. 저장소를 처음 만들면, Git은 바로 ‘master’라는 이름의 브랜치를 만들어 준다. 이 새로운 저장소에 새로운 파일을 추가한다거나 추가한 파일의 내용을 변경하여 그 내용을 저장(커밋, commit)하는 것은 모두 ‘master’라는 이름의 브랜치를 통해 처리할 수 있다. 12345678git branch &lt;branchname&gt; # 브랜치 생성git branch # 브랜치 확인git branch -r # remote 브랜치 확인git branch -a # 모든 사용가능한 브랜치 확인git checkout &lt;branchname&gt; # 브랜치 지정git checkout -b &lt;branchname&gt; # 브랜치 생성, 체크아웃git merge &lt;branchname&gt; # 브랜치 병합git branch -d &lt;branchname&gt; # 브랜치 삭제 참고 https://backlog.com/git-tutorial/kr/stepup/stepup1_1.html https://github.com/ulgoon/dss-linux-git","categories":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/categories/Git/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"},{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/tags/Git/"}]},{"title":"ubuntu permission","slug":"ubuntu-permission","date":"2018-11-27T08:44:04.000Z","updated":"2018-11-28T09:35:45.000Z","comments":true,"path":"2018/11/27/ubuntu-permission/","link":"","permalink":"https://p829911.github.io/2018/11/27/ubuntu-permission/","excerpt":"","text":"파일 정보 보기 ls -al: 현재 위치에 있는 파일들을 자세히 보여주는 명령 파일 Type 퍼미션정보 링크수 소유자 소유그룹 용량 생성날짜 파일이름 d rwxr-xr-x 28 p829911 p829911 4096 11월 27 20:30 .ipython 파일 Type: d (디렉토리), ㅣ (링크파일), - (일반파일) 퍼미션정보: 해당 파일에 어떠한 퍼미션이 부여되어 있는지 링크수: 해당 파일이 링크된 수, 윈도우의 바로가기와 같다. in [대상파일][링크파일]명령으로 만든다. 소유자: 해당 파일의 소유자 이름 소유그룹: 해당 파일을 소유한 그룹이름 용량: 파일의 용량 생성날짜: 파일이 생성된 날짜 파일이름: 파일의 이름 퍼미션 정보 앞에서 두번째부터 아홉번째까지 퍼미션 정보이다. rwxr-xr-x 퍼미션 종류 r : 파일의 읽기 권한 w : 파일의 쓰기 권한 x : 파일의 실행 권한 퍼미션의 사용자지정 소유자: 소유자에 대한 퍼미션 지정 rwx 그룹: 소유그룹에 대한 퍼미션 지정 r-x 공개: 모든 사용자들에 대한 퍼미션 지정 r-x -: 그 퍼미션은 없다 소유자는 읽기, 쓰기, 실행을 허용하고 파일의 소유그룹에 속하고 있는 사용자들은 읽기 실행만 허용하고 이외에 나머지 모든 사용자들도 읽기, 실행만 허용한다. 퍼미션 변경하기chmod [변경될 퍼미션값][변경할 파일] 각 퍼미션 기호를 숫자로 변환한다. ( r = 4, w = 2, x = 1)ex) r - x = 4 0 1 변환한 숫자를 합산한다.ex) 4 0 1 = 5 rwxr-xr-x = 755 chmod 775 [변경할 파일] : 변경할 파일이 755에 해당되는 퍼미션으로 변경된다. 디렉토리의 경우 -R 옵션을 사용하면 하위 디렉토리의 모든 디렉토리 및 파일의 퍼미션이 변경된다.ex) chmod -R 777 [변경할 디렉토리] 소유자 변경하기chown [변경할 소유자][변경할 파일] 이 명령으로 소유자뿐만 아니라 소유그룹도 변경할 수 있다. [변경할 소유자]에 .그룹이름 형식으로 입력하면 된다. ex) p829911.text 파일의 소유자를 p829911 소유그룹을 p829911로 동시에 변경할 경우chown p829911.p829911 p829911.text","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"ubuntu apt 명령어","slug":"ubuntu-apt-명령어","date":"2018-11-27T07:50:51.000Z","updated":"2018-11-27T08:05:17.000Z","comments":true,"path":"2018/11/27/ubuntu-apt-명령어/","link":"","permalink":"https://p829911.github.io/2018/11/27/ubuntu-apt-명령어/","excerpt":"","text":"우분투에서 패키지를 관리하는 명령어가 몇 가지 있다. 그 중 apt-get과 apt-cache를 결합한 apt에 관한 명령어를 알아보겠다. 패키지 목록 갱신 1apt update 모든 패키지를 최신 버전으로 업그레이드 12apt install upgradeapt full-upgrade # 의존성 고려한 패키지 업그레이드 패키지 설치 1apt install package_name 패키지 삭제 1apt remove package_name 패키지 삭제(설정 파일 포함) 1apt purge package_name 불필요한 패키지 제거 1apt autoremove 패키지 검색 1apt search package_name 패키지 상세 정보 출력 1apt show package_name apt 명령어 사용법 &amp; 옵션 1apt -h 패키지 리스트 출력 1apt list 권한 문제가 발생할 경우 sudo 명령을 붙여 root로 실행할 수 있다.","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"교차 검증","slug":"교차-검증","date":"2018-11-27T06:32:01.000Z","updated":"2018-12-13T11:23:22.000Z","comments":true,"path":"2018/11/27/교차-검증/","link":"","permalink":"https://p829911.github.io/2018/11/27/교차-검증/","excerpt":"","text":"이 포스트는 fastcampus에서 강의를 하고 계시는 김도형 박사님의 강의록을 따라 쓰며 연습한 포스트입니다. 데이터 사이언스 스쿨 표본 내 성능과 표본 외 성능회귀분석 모형을 만들기 위해서는 모수 추정 즉 학습을 위한 데이터 집합이 필요하다. 보통 회귀분석 성능을 이야기할 때는 이 학습 데이터 집합의 종속 변수값을 얼마나 잘 예측하였는지를 결정 계수(codefficient of determination) 등을 이용하여 따진다. 이러한 성능을 표본 내 성능 검증(in-sample testing)이라고 한다. 그런데 회귀분석 모형을 만드는 목적 중 하나는 종속 변수의 값을 아직 알지 못하고 따라서 학습에 사용하지 않은 표본에 대해 종속 변수의 값을 알아내고자 하는 것 즉 예측(prediction)이다. 이렇게 학습에 쓰이지 않는 표본 데이터 집합의 종속 변수 값을 얼마나 잘 예측하는가를 검사하는 것을 표본 외 성능 검증(out-of-sample testing) 혹은 교차 검증(cross validation)이라고 한다. 과최적화일반적으로 표본 내 성능과 표본 외 성능은 비슷한 수준을 보이지만 경우에 따라서는 표본 내 성능은 좋으면서 표본 외 성능이 상대적으로 많이 떨어지는 수도 있다. 이러한 경우를 과최적화(overfitting)라고 한다. 과최적화가 발생하면 학습에 쓰였던 표본 데이터에 대해서는 종속변수의 값을 잘 추정하지만 새로운 데이터를 주었을 때 전혀 예측하지 못하기 때문에 예측 목적으로는 쓸모없는 모형이 된다. 검증용 데이터 집합교차 검증을 하려면 두 종류의 데이터 집합이 필요하다. 모형 추정 즉 학습을 위한 데이터 집합 (training data set) 성능 검증을 위한 데이터 집합 (test data set) 두 데이터 집합 모두 종속 변수값이 있어야 한다. 따라서 보통은 가지고 있는 데이터 집합을 학습용과 검증용으로 나누어 학습용 데이터만을 사용하여 회귀분석 모형을 만들고 검증용 데이터로 성능을 계산하는 학습/검증 데이터 분리(train-test split) 방법을 사용한다. statsmodels 패키지에서의 교차 검증사실 소수의 입력 변수와 소규모 데이터를 사용하는 전통적인 회귀분석에서는 다항 회귀 등의 방법으로 모형 차수를 증가시키지 않는 한 과최적화가 잘 발생하지 않는다. 따라서 statsmodels 패키지에는 교차 검증을 위한 기능이 별도로 준비되어 있지 않고 사용자가 직접 코드를 작성해야 한다. scikit-learn의 교차 검증 기능독립 변수의 개수가 많은 빅데이터에서는 과최적화가 쉽게 발생한다. 따라서 scikit-learn 의 model_selection 서브 패키지는 교차 검증을 위한 다양한 명령을 제공한다. 단순 데이터 분리train_test_split 명령은 데이터를 학습용 데이터와 검증용 데이터로 분리한다. 1train_test_split(data, data2, test_size, train_size, random_state) data: 독립 변수 데이터 배열 또는 pandas 데이터 프레임 data2: 종속 변수 데이터. data인수에 종속 변수 데이터가 같이 있으면 생략할 수 있다. test_size: 검증용 데이터 개수. 1보다 작은 실수이면 비율을 나타낸다. train_size: 학습용 데이터의 개수. 1보다 작은 실수이면 비율을 나타낸다. test_size와 train_size중 하나만 있어도 된다. random_state: 난수 시드 1234from sklearn.model_selection import train_test_splitdf_train, df_test = train_test_split(df, test_size=0.3, random_state=0)df_train.shape, df_test.shape 12dfx_train, dfx_test, dfy_train, dfy_test = train_test_split(dfx, dfy, test_size=0.3, random_state=0)dfx_train.shape, dfy_train.shape, dfx_test.shape, dfy_test.shape K- 폴드 교차 검증데이터의 수가 적은 경우에는 이 데이터 중의 일부인 검증 데이터의 수도 적기 때문에 검증 성능의 신뢰도가 떨어진다. 그렇다고 검증 데이터의 수를 증가시키면 학습용 데이터의 수가 적어지므로 정상적인 학습이 되지 않는다. 이러한 딜레마를 해결하기 위한 검증 방법이 K-폴드(K-fold) 교차 검증 방법이다. K-폴드 교차 검증에서는 전체 데이터를 K개의 부분집합($\\{1, 2, \\cdots , K\\}$)로 나눈 뒤 다음과 같이 학습과 검증을 반복한다. 데이터 $\\{1, 2, \\cdots, K - 1\\}$를 학습용 데이터로 사용하여 회귀분석 모형을 만들고 데이터 $\\{K\\}$ 로 교차 검증을 한다. 데이터 $\\{1, 2, \\cdots, K - 2, K\\}$를 학습용 데이터로 사용하여 회귀분석 모형을 만들고 데이터 $\\{K-1\\}$로 교차 검증을 한다. $\\vdots$ 데이터 $\\{2, \\cdots, K\\}$를 학습용 데이터로 사용하여 회귀분석 모형을 만들고 데이터 $\\{1\\}$로 교차 검증을 한다. 이렇게 하면 총 K개의 모형과 K개의 교차 검증 성능이 나온다. 이 K개의 교차 검증 성능을 평균하여 최종 교차 검증 성능을 계산한다. scikit-learn 패키지의 model_selection 서브 패키지는 KFold 클래스를 비롯한 다양한 교차 검증 생성기를 제공한다. 이 생성기의 split 메서드는 학습용과 검증용의 데이터 인덱스를 출력하는 파이썬 반복자(iterator)를 반환한다. 123456789101112131415161718from sklearn.model_selection import KFoldscores = np.zeros(5)cv = KFold(5, shuffle=True, random_state=0)for i, (idx_train, idx_test) in enumerate(cv.split(df)): df_train = df.iloc[idx_train] df_test = df.iloc[idx_test] model = sm.OLS.from_formula(\"MEDV ~ \" + \"+\".join(boston.feature_names), data=df_train) result = model.fit() pred = result.predict(df_test) rss = ((df_test.MEDV - pred) ** 2).sum() tss = ((df_test.MEDV - df_test.MEDV.mean()) ** 2).sum() rsquared = 1 - rss/tss scores[i] = rsquared print(\"train R2 = &#123;:.8f&#125;, test R2 = &#123;:.8f&#125;\".format(result.rsquared, rsquared))","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Regression","slug":"Math/Regression","permalink":"https://p829911.github.io/categories/Math/Regression/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Regression","slug":"Regression","permalink":"https://p829911.github.io/tags/Regression/"}]},{"title":"hexo mathjax","slug":"hexo-mathjax","date":"2018-11-26T14:36:53.000Z","updated":"2018-11-26T14:53:50.000Z","comments":true,"path":"2018/11/26/hexo-mathjax/","link":"","permalink":"https://p829911.github.io/2018/11/26/hexo-mathjax/","excerpt":"","text":"rendering engine changeHexo의 기본 renderer인 hexo-renderer-marked는 mathjax 문법을 지원하지 않는다. 따라서 mathjax를 지원하는 rendering engine으로 교체해준다. 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save &lt;blog dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js를 열어 return값을 text로 수정한다. 12345function formatText(text) &#123; // Fit kramed's rule: $$ + \\1 + $$ // return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$'); return text;&#125; install mathjaxmathjax plugin 설치 1npm install hexo-renderer-mathjax --save &lt;blog dir&gt;/node_modules/hexo-renderer-kramed/node_modules/hexo-renderer-mathjax/mathjax.html 을 열고 URL을 수정해준다. 12&lt;!-- &lt;script src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"&gt;&lt;/script&gt; --&gt;&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'&gt;&lt;/script&gt; LaTex와 markdown 문법 충돌 해결하기&lt;blog dir&gt;/node_modules/kramed/lib/rules/inline.js를 열고 다음과 같이 수정한다. 12escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, Mathjax 사용하기사용하고 있는 theme의 _config.yml파일을 열고 다음과 같이 수정한다. 12mathjax: enable: true markdown post 작성post 작성시 header 부분에 mathjax: true를 넣어주면 블로그에서 수식이 보이게 된다.","categories":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/tags/Git/"},{"name":"Blog","slug":"Blog","permalink":"https://p829911.github.io/tags/Blog/"},{"name":"Mathjax","slug":"Mathjax","permalink":"https://p829911.github.io/tags/Mathjax/"}]},{"title":"분산 분석","slug":"분산-분석","date":"2018-11-26T14:21:57.000Z","updated":"2018-12-13T11:23:10.000Z","comments":true,"path":"2018/11/26/분산-분석/","link":"","permalink":"https://p829911.github.io/2018/11/26/분산-분석/","excerpt":"","text":"이 포스트는 fastcampus에서 강의를 하고 계시는 김도형 박사님의 강의록을 따라 쓰며 연습한 포스트입니다. 데이터 사이언스 스쿨 선형회귀분석의 결과가 얼마나 좋은지는 단순히 잔차제곱합(RSS: Residual sum of square)으로 평가할 수 없다. 변수의 단위 즉, 스케일이 달라지면 회귀분석과 상관없이 잔차제곱합도 달라지기 때문이다. 분산 분석(ANOVA: Analysis of Variance)은 종속변수의 분산과 독립변수의 분산간의 관계를 사용하여 선형회귀분석의 성능을 평가하고자 하는 방법이다. 분산 분석은 서로 다른 두 개의 선형회귀분석의 성능 비교에 응용할 수 있으며 독립변수가 카테고리 변수인 경우 각 카테고리 값에 따른 영향을 정량적으로 분석하는데도 사용된다. $\\hat{y}$를 종속변수 $y$의 샘플 평균이라고 하자. \\hat{y} = \\frac{1}{N} \\sum_{i=1}^N y_iTSS (total sum of squares) \\text{TSS} = \\sum_{i=1}^N (y_i-\\bar{y})^2 = (y-\\bar{y})^T(y-\\bar{y})종속변수값의 움직임의 범위를 나타낸다. ESS(explained sum of squares) \\text{ESS} = \\sum_{i=1}^N (\\hat{y_i}-\\bar{\\hat{y}})^2 = (\\hat{y}-\\bar{\\hat{y}})^T(\\hat{y}-\\bar{\\hat{y}})회귀 분석에 의해 예측한 값 $\\hat{y}$의 분산을 나타낸다. 모형에서 나온 예측값의 움직임의 범위를 뜻한다. RSS (residual sum of squares) \\text{RSS} = \\sum_{i=1}^N(y_i-\\hat{y_i})^2 = e^Te잔차 $e$의 분산을 나타낸다. 잔차의 움직임의 범위, 즉 오차의 크기를 뜻한다. 만약 회귀모형이 상수항을 포함하여 올바르게 정의되었다면 잔차의 평균이 0이 된다. 즉 종속변수의 평균과 모형 예측값의 평균이 같아진다. \\bar{e} = \\bar{y} - \\bar{\\hat{y}} = 0 \\bar{y} = \\bar{\\hat{y}}그리고 이 분산값들 간에는 다음과 같은 관계가 성립한다. \\text{TSS} = \\text{ESS} + \\text{RSS}위 식이 말하는 바는 다음과 같다. 모형 예측치의 움직임의 크기(분산)은 종속변수의 움직임의 크기(분산)보다 클 수 없다. 모형의 성능이 좋을 수록 모형 예측치의 움직임의 크기는 종속변수의 움직임의 크기와 비슷해진다. example 123456789101112import numpyimport pandasfrom sklearn.datasets import make_regressionx0, y, coef = make_regression(n_samples=100, n_features=1, noise=30, coef=True, random_state=0)dfx0 = pd.DataFrame(x0, columns=[\"X\"])dfx = sm.add_constant(dfx0)dfy = pd.DataFrame(y, columns=[\"Y\"])df = pd.concat([dfx, dfy], axis=1)model = sm.OLS.from_formula(\"Y ~ X\", data=df)result = model.fit() 12345print(\"TSS = \", result.uncentered_tss)print(\"ESS = \", result.mse_model)print(\"RSS = \", result.ssr)print(\"ESS + RSS = \", result.mse_model + result.ssr)print(\"R squared = \", result.rsquared) 결정 계수(Coefficient of Determination) 위의 분산 관계식에서 모형의 성능을 나타내는 결정계수(Coefficient of Determination) $R^2$를 정의할 수 있다. R^2 \\equiv 1- \\dfrac{\\text{RSS}}{\\text{TSS}} = \\dfrac{\\text{ESS}}{\\text{TSS}}분산 관계식과 모든 분산값이 0보다 크다는 점을 이용하면 $R^2$의 값은 다음과 같은 조건을 만족한다. 0 \\leq R^2 \\leq 1여기에서 $R^2$가 0 이라는 것은 오차의 분산 RSS가 최대이고 회귀분석 예측값의 분산 ESS가 0인 경우이므로 회귀분석 결과가 아무런 의미가 없다는 뜻이다. 반대로 $R^2$가 1이라는 것은 오차의 분산 RSS가 0이고 회귀분석 예측의 분산 ESS가 TSS와 같은 경우이므로 회귀분석 결과가 완벽하다는 뜻이다. 따라서 결정계수값은 회귀분석의 성능을 나타내는 수치라고 할 수 있다. 분산 분석표 분산 분석의 결과는 보통 다음과 같은 분산 분석표를 사용하여 표시한다. 아래의 표에서 $N$은 데이터의 갯수, $K$는 모수(독립변수의 갯수, 상수항 포함)의 갯수를 뜻한다. source degree of freedom sum of square mean square F test-statistics p-value Regression $K -1$ $\\text{ESS}$ $s_\\hat{y}^2 = \\dfrac{\\text{ESS}}{K-1}$ $F = \\dfrac{s_\\hat{y}^2}{s_e^2}$ p-value Residual $N - K$ $\\text{RSS}$ $s_e^2 = \\dfrac{\\text{RSS}}{N-K}$ Total $N - 1$ $\\text{TSS}$ $s_y^2 = \\dfrac{\\text{TSS}}{N-1}$ $R^2$ $\\dfrac{\\text{ESS}}{\\text{TSS}}$ 결정 계수와 상관 계수 $y$와 $\\hat{y}$의 샘플 상관계수 $r$의 제곱은 결정 계수 $R^2$와 같다. 상수항이 없는 모형의 경우 모형에서 상수항을 지정하지 않은 경우에는 결정계수의 정의에 사용되는 TSS의 정의가 다음과 같이 달라진다. \\text{TSS} = \\sum_{i=1}^{N}y_i^2 = y^Ty즉, 실제 샘플평균과 상관없이 $\\bar{y} = 0$ 이라는 가정하에 TSS를 계산한다. 이렇게 정의하지 않으면 TSS = RSS + ESS 관계식이 성립하지 않아서 결정계수의 값이 1보다 커지게 된다. 따라서 모형의 결정계수를 비교할 때 상수항이 없는 모형과 상수항이 있는 모형은 직접 비교하면 안된다. F 검정을 이용한 모형 비교 F 검정을 이용하면 다음과 같이 포함관계에 있는 두 모형의 성능을 비교할 수 있다. 전체 모형(Full Model): y = w_0 + w_1x_1 + w_2x_2 + w_3x_3 축소 모형(Reduced Model): y = w_0 + w_1x_1 다음과 같은 귀무가설을 검정하는 것은 위의 두 모형이 실질적으로 같은 모형이라는 가설을 검정하는 것과 같다. H_0 : w_2 = w_3 = 0이 검정도 F검정을 사용하여 할 수 있다. StatsModels에서는 anova_lm명령에 두 모형의 result 객체를 인수로 넣어주면 이러한 검정을 할 수 있다. 인수를 넣어줄 때는 축소 모형(reduced model), 전체 모형(full model)의 순서로 넣어준다.","categories":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/categories/Math/"},{"name":"Regression","slug":"Math/Regression","permalink":"https://p829911.github.io/categories/Math/Regression/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://p829911.github.io/tags/Math/"},{"name":"Regression","slug":"Regression","permalink":"https://p829911.github.io/tags/Regression/"}]},{"title":"Jupyber notebook matplotlib 한글 설정","slug":"Jupyber-notebook-matplotlib-한글-설정","date":"2018-11-26T13:25:40.000Z","updated":"2018-11-26T14:52:32.000Z","comments":true,"path":"2018/11/26/Jupyber-notebook-matplotlib-한글-설정/","link":"","permalink":"https://p829911.github.io/2018/11/26/Jupyber-notebook-matplotlib-한글-설정/","excerpt":"","text":"우분투 폰트 경로 /usr/share/fonts/ 나눔 글꼴 또는 다른 폰트도 /usr/share/fonts/ 폴더에 복사에서 사용가능하다. 나눔글꼴 설치 12sudo apt-get install fonts-nanum*sudo fc-cache -fv apt-get 명령으로 나눔글꼴 설치 후, fc-cache 명령으로 폰트 캐시 삭제 다른 ttf 폰트 12sudo cp new_font.ttf / usr/share/fontssudo fc-cache -fv 우분투 폰트 경로로 ttf폰트 복사 후, fc-cache 명령으로 폰트 캐시 삭제 matplotlib 폴더에 글꼴 추가 123sudo cp /usr/share/fonts/truetype/D2Coding/D2* /home/p829911/.local/lib/python3.6/site-packages/matplotlib/mpl-data/rm -rf /home/ubuntu/.cache/matplotlib/* matplotlib 폴더에 글꼴을 복사 한 후 matplotlib의 폰트 캐시를 삭제 12# 캐쉬 디렉토리matplotlib.get_cachedir() 내 컴퓨터에 저장되어 있는 폰트 리스트 가져오기 123456789import matplotlib.font_manager as fmfont_list = fm.findSystemFonts(fontpaths=None, fontext='ttf')# 전체개수print(len(font_list)) # 처음 10개만 출력font_list[:10] 사용가능한 시스템의 TTF 폰트 목록 123456import matplotlib.font_manager as fmfont_list = [(f.name, f.fname) for f in fm.fontManager.ttflist]print(len(font_list))font_list[:10] 내가 원하는 D2Coding 폰트의 저장 위치를 불러오기 123for font in font_list: if \"D2\" in font[0]: print(font) rcParams 를 설정 파일에 직접 적어주기 - 모든 노트북에 공통 적용 font.family: D2Coding 이곳에 폰트를 지정해 주면 노트북을 실행 할 때 바로 로드되도록 설정할 수 있다. 1print(matplotlib.matplotlib_fname()) 1vi /home/p829911/.local/lib/python3.6/site-packages/matplotlib/mpl-data/matplotlibrc matplotlibrc파일에서 font.family를 D2Coding으로 설정해준다. 1234567891011import numpy as npimport matplotlib.pyplot as plt%matplotlib inlinedata = np.random.randint(-100, 100, 50).cumsum()dataplt.plot(range(50), data, 'r')plt.title('가격변동 추이')plt.ylabel('가격')plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/categories/Python/"}],"tags":[{"name":"Jupyter","slug":"Jupyter","permalink":"https://p829911.github.io/tags/Jupyter/"},{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/tags/Python/"}]},{"title":"Jupyter notebook 글꼴 설정","slug":"Jupyter-notebook-글꼴-설정","date":"2018-11-26T10:51:23.000Z","updated":"2018-11-26T14:52:46.000Z","comments":true,"path":"2018/11/26/Jupyter-notebook-글꼴-설정/","link":"","permalink":"https://p829911.github.io/2018/11/26/Jupyter-notebook-글꼴-설정/","excerpt":"","text":"D2Coding 설치 12345cd /home/username/.jupytermkdir customcd customtouch custom.cssvi custom.css 만약 custom.css에 쓰기 권한이 없으면 chmod명령으로 파일 권한을 바꿔준다. 1sudo chmod 777 custom.css vi 편집기로 custom.css 파일을 연 후 다음과 같이 설정 해 준다. 1.CodeMirror pre &#123;font-family: D2Coding; font-size: 12pt; line-height: 120%;&#125; jupyter notebook을 실행하면 글꼴이 D2Coding으로 바뀐 것을 볼 수 있다.","categories":[{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/categories/Python/"}],"tags":[{"name":"Jupyter","slug":"Jupyter","permalink":"https://p829911.github.io/tags/Jupyter/"},{"name":"Python","slug":"Python","permalink":"https://p829911.github.io/tags/Python/"}]},{"title":"git blog 관리하기","slug":"git-blog-관리하기","date":"2018-11-26T10:50:56.000Z","updated":"2018-12-13T14:11:23.000Z","comments":true,"path":"2018/11/26/git-blog-관리하기/","link":"","permalink":"https://p829911.github.io/2018/11/26/git-blog-관리하기/","excerpt":"","text":"새 저장소(repository) 만들기Github에서 새 저장소(repository)를 만든다. 이 때 저장소의 이름을 자신의 username뒤에 .github.io가 붙은 이름으로 만든다. 이렇게 만들어 줘야 username.github.io의 도메인으로 접속할 수 있는 블로그가 된다. Hexo 설치하기git과 node.js는 설치돼 있어야 한다. 12sudo apt install npmnpm install -g hexo-cli # 오류 날 시 앞에 sudo를 붙여준다 1hexo -v 위의 명령어로 hexo가 제대로 설치 되었는지 확인 한다. Hexo 설치가 완료되었으면 다음과 같은 명령어를 입력해서 Hexo 디렉토리를 초기화한다. 1hexo init &lt;디렉토리명&gt; 설치가 모두 잘 되었다면 다음 명령어를 입력해서 내장 서버를 돌릴 수 있다. 123hexo server# 서버 실행 후 창 오픈hexo s -o 브라우저에서 http://0.0.0.0:4000/ 으로 접속해서 확인 할 수 있다. deployHexo가 설치된 디렉토리로 가서 _config.yml 파일을 열어 Site, URL, Deployment 항목을 수정해준다. 그리고 정적 파일을 생성한다. 1hexo generate 디플로이를 하기 위해서는 hexo-deployer-git 플러그인이 필요하다. 아래의 명령어를 사용해서 설치한다. 1npm install --save hexo-deployer-git 생성이 잘 되었다면 디플로이 명령어를 사용한다. 1hexo deploy Hueman 테마 적용하기블로그 루트 폴더에서 명령어로 테마를 받는다. 1git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman blog 폴더에 있는 _config.yml에서 Theme부분을 landscape에서 hueman으로 바꿔준다. themes/hueman 폴더에 있는 _config.yml.example을 _config.yml로 바꾼다. 12cd blog/themes/huemanmv _config.yml.example _config.yml 최신 버전을 다운받기 위해 pull해준다. 12cd themes/huemangit pull Hueman 테마의 Insight Search 검색엔진을 사용하기 위해 npm으로 hexo-generator-json-content을 설치한다. 1npm install -S hexo-generator-json-content hueman의 테마는 hueman폴더 안에 있는 _config.yml에서 설정할 수 있다. 포스트 작성하기1hexo new post \"post name\" 그러면 [blogFolder]/source/_posts에 새로운 마크다운 파일이 생성된다.자동으로 제목과 생성날짜가 들어간다. 글을 마크다운 파일로 작성 한 후 12hexo generatehexo deploy or 123hexo generate --deploy# 단축키hexo g -d 테마가 적용 안되는 경우12hexo cleanhexo generate --deploy","categories":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://p829911.github.io/tags/Git/"},{"name":"Blog","slug":"Blog","permalink":"https://p829911.github.io/tags/Blog/"}]},{"title":"우분투 Root 비밀번호 설정","slug":"우분투-Root-비밀번호-설정","date":"2018-11-26T10:46:43.000Z","updated":"2018-11-26T11:07:04.000Z","comments":true,"path":"2018/11/26/우분투-Root-비밀번호-설정/","link":"","permalink":"https://p829911.github.io/2018/11/26/우분투-Root-비밀번호-설정/","excerpt":"","text":"우분투를 설치하면 기본으로 Root 비밀번호가 없는 상태이다. 아래와 같은 방법으로 root 비밀번호를 설정해본다. root 비밀번호 설정 1sudo passwd 위와 같이 비밀번호를 설정 했다면 1su 명령을 통해 root에 로그인 할 수 있다. passwd 1passwd 현재 로그인한 사용자 계정의 비밀번호를 변경할 수 있는 명령어이다. root에서 user 비밀번호 변경 1passwd p829911 root에서 p829911이라는 사용자의 비밀번호를 변경하고 싶을 때 사용하는 명렁어이다.","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"우분투 한글 입력기 설치","slug":"우분투-한글-입력기-설치","date":"2018-11-24T18:14:50.000Z","updated":"2018-11-24T18:51:55.000Z","comments":true,"path":"2018/11/25/우분투-한글-입력기-설치/","link":"","permalink":"https://p829911.github.io/2018/11/25/우분투-한글-입력기-설치/","excerpt":"","text":"한글 설치 fcitx-hangul 설치 1sudo apt-get install fcitx-hangul System Setting (설정) &gt; Language Support(언어 지원) 을 실행해서 설치되지 않은 언어팩 모두 설치한다. 키보드 입력기를 ibus에서 fcitx로 변경한다. 재부팅 시 오른쪽 위에 아래의 첫번째에서 보는 것과 같은 아이콘이 생성된 것을 볼 수 있다. 한영 변환 설정 &gt; 장치 &gt; 키보드 로 들어간 뒤 입력 중의 다음 입력소스로 전환, 이전 입력소스로 전환을 사용 않음으로 바꿔준다. 사용 않음으로 바꿔주기 위해선 클릭 후 backspace를 누르면 된다. 상단 메뉴바 오른쪽의 입력기 선택(위 그림에서 세번째) 후 현재 입력기 설정 클릭 Keyboard-English(US)가 있다면 + 를 눌러 Hangul을 추가한다. (uncheck “Only Show Current Language”). Korean이 아닌 Hangul을 선택한다. 전역 설정 &gt; 단축키 &gt; 입력기 전환에 ‘Shift + Space’를 추가한다. 전역 설정 &gt; 프로그램 윈도우 사이에 상태 공유를 ‘모두’로 바꿔준다","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]},{"title":"우분투 데이터분석 환경설정","slug":"우분투-데이터분석-환경설정","date":"2018-11-24T17:25:25.000Z","updated":"2018-11-24T18:12:21.000Z","comments":true,"path":"2018/11/25/우분투-데이터분석-환경설정/","link":"","permalink":"https://p829911.github.io/2018/11/25/우분투-데이터분석-환경설정/","excerpt":"","text":"우분투 버전: Ubuntu 18.04.1 LTS 이 글은 데이터 분석을 공부하면서 window 사용자가 우분투에 데이터 분석 환경 설정 하며 겪은 시행착오와 그 단계들을 모아둔 글입니다. 오류와 path충돌 때문에 눈물을 머금고 우분투를 4번 정도 다시 깔면서 다음에 다시 설치해야 할 상황이 왔을 때 참고하기 위한 글이고, 우분투로 처음 데이터 분석 환경 설정을 하려고 하는 분들을 위해 정리하는 글입니다. 이 포스트와 다음과 같은 내용이 포함되어 있습니다. 한글 입력기 설치 root 비밀번호 설정 패키지 관리 툴 apt 사용법 슬랙 설치 vim 설치 git 설치 python3 설치 및 기본 설정 python3 데이터 분석 관련 패키지 설치 markdown 편집기 typora 설치 Atom &amp; Atom package 설치 mysql &amp; mysql workbench 설치 AWS(Amazon Web Services) 가입 및 접속 AWS와 파일 주고 받기를 할 수 있는 FileZilla 설치 및 사용법","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://p829911.github.io/tags/Ubuntu/"}]}]}